<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Object Oriented Tools &mdash; CanlabCore 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="CanlabCore 1.0 documentation" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="mat-modindex.html" title="MATLAB Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CanlabCore 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="object-oriented-tools">
<h1>Object Oriented Tools<a class="headerlink" href="#object-oriented-tools" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="module-&#64;canlab_dataset">
<span id="canlab-dataset"></span><h1>canlab_dataset<a class="headerlink" href="#module-@canlab_dataset" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;canlab_dataset.bars">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">bars</code><span class="sig-paren">(</span><em>obj</em>, <em>varnames</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Bar plot for canlab_dataset object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[dat, descrip, colors, h1, s1] = bars(obj, varnames, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">canlab_dataset object</p>
</dd>
<dt><strong>varnames:</strong></dt>
<dd><p class="first last">Cell string of variable names to plot</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><blockquote class="first">
<div><dl class="docutils">
<dt><strong>colors:</strong></dt>
<dd><p class="first last">defined colors (default are set by scn_standard_colors.m)</p>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt><strong>nofig:</strong></dt>
<dd><p class="first last">do not generate figure</p>
</dd>
</dl>
<p>Takes any optional inputs to barplot_colored.m</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">data matrix for each variable</p>
</dd>
<dt><strong>descrip:</strong></dt>
<dd><p class="first last">the description for this variable</p>
</dd>
<dt><strong>colors:</strong></dt>
<dd><p class="first last">selected colors (default are set by scn_standard_colors.m)</p>
</dd>
<dt><strong>h1:</strong></dt>
<dd><p class="first last">figure handle</p>
</dd>
<dt><strong>s1:</strong></dt>
<dd><p class="first last">axis handle</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>create_figure(&#39;NPS values - All subjects&#39;);

varnames = {&#39;15&#39; &#39;13&#39; &#39;11&#39; &#39; 9&#39; &#39;16&#39; &#39;14&#39; &#39;12&#39; &#39;10&#39;};
xvals = [1 2 4 5 8 9 11 12];
colors = {[1 0 0] [0 1 0] [1 0 0] [0 1 0] [1 0 0] [0 1 0] [1 0 0] [0 1 0]};
bars(LevoNPS, varnames, &#39;x&#39;, xvals, &#39;colors&#39;, colors, &#39;XTickLabels&#39;, varnames, &#39;within&#39;, &#39;nofig&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.concatenate">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">concatenate</code><span class="sig-paren">(</span><em>D</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates Subject-level and Event-level data across all subjects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[names ids dat] = concatenate(D, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">canlab_dataset object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>a logical array</strong></dt>
<dd><p class="first last">a vector of 1/0 values to use as wh_keep</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>names:</strong></dt>
<dd><p class="first last">cell array of variable names</p>
</dd>
<dt><strong>ids:</strong></dt>
<dd><p class="first last">subject IDs matching data rows in dat</p>
</dd>
<dt><strong>dat:</strong></dt>
<dd><dl class="first last docutils">
<dt>subjects*events x variables matrix</dt>
<dd><ul class="first last simple">
<li>subject number, event number are included</li>
<li>all subject-level and event-level data are included</li>
<li>this format appropriate for, e.g., SAS/HLM</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>descrips:</strong></dt>
<dd><p class="first last">cell array of variable descriptions</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[names, ids, flatdat] = concatenate(D);
id_numbers = flatdat(:, 1);

wh_subjs = true(size(D.Subj_Level.id));
wh_subjs([13 18 19]) = false;
[names, ids, dat] = concatenate(D, wh_subjs);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.get_var">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">get_var</code><span class="sig-paren">(</span><em>D</em>, <em>varname</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.get_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Subject-level or Event-level variable from dataset D and return in
rect matrix and cell array. Multiple variables can be requested, but 
all data requested must be either numeric or text, and not a combination of the two.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[dat, datcell, wh_level, descrip] = get_var(D, varname, [opt inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>varname:</strong></dt>
<dd><dl class="first last docutils">
<dt>the name of a variable to get from dataset</dt>
<dd><ul class="first last simple">
<li>Looks for var name at either level, returns error if exists at both levels</li>
<li>can be a cell array of multiple var names
in this case, dat is a n x m matrix, where n=subjs and m=variables requested</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first"><strong>a logical array vector of 1/0 values to use as wh_keep</strong></p>
<dl class="docutils">
<dt><strong>conditional:</strong></dt>
<dd><p class="first last">to be followed by a cell array; the first cell is the name
of the variable to be conditionally selected upon, the second cell
contains the condition which must be met.
Example: get_var(D, &#8216;DeltaDon&#8217;, &#8216;conditional&#8217;, {&#8216;trained&#8217; 1})
will get DeltaDon whenever trained==1.  Currently only implemented for
event-level data.  Could be expanded to include multiple conditions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dat:</strong></dt>
<dd><blockquote class="first">
<div><p>rect matrix of subjects X events (X variables)</p>
</div></blockquote>
<ul class="last simple">
<li>good for plotting individuals, means/std. errors across subjects</li>
<li>is actually a cell matrix if textual data is requested.</li>
</ul>
</dd>
<dt><strong>datcell:</strong></dt>
<dd><blockquote class="first">
<div><p>1 x subjects cell array, each cell containing event data for one subject</p>
</div></blockquote>
<ul class="last simple">
<li>good for input into some stats functions, e.g., glmfit_multilevel
and igls.m</li>
</ul>
</dd>
<dt><strong>wh_level:</strong></dt>
<dd><p class="first last">1 = &#8216;Subject&#8217;; 2 = &#8216;Event&#8217;;</p>
</dd>
<dt><strong>descrip:</strong></dt>
<dd><p class="first last">the description for this variable</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.glm">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">glm</code><span class="sig-paren">(</span><em>D</em>, <em>Yvarname</em>, <em>Xvarnames</em>, <em>wh_keep</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.glm" title="Permalink to this definition">¶</a></dt>
<dd><p>predict Y from X using GLM</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">glm</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Yvarname</span><span class="p">,</span> <span class="n">Xvarnames</span><span class="p">,</span> <span class="n">wh_keep</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>Yvarname:</strong></dt>
<dd><p class="first last">the name of a variable to predict. must be subject level</p>
</dd>
<dt><strong>Xvarnames:</strong></dt>
<dd><p class="first last">the name(s) of predictor variables. if multiple, put in
cell array. must be subject_level</p>
</dd>
<dt><strong>wh_keep:</strong></dt>
<dd><p class="first last">a logical vector of 1/0 values</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>out:</strong></dt>
<dd><p class="first last">structure containing same output as for glmfit()
out.b: a vector of coefficient estimates
out.dev: the deviance of the fit
out.stat: see glmfit documentation for stat structure fields</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">glm</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;DeltaDon_avg&#39;</span><span class="p">,</span> <span class="n">prednames</span><span class="p">,</span> <span class="n">wh_keep</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.glm_multilevel">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">glm_multilevel</code><span class="sig-paren">(</span><em>D</em>, <em>Yvarname</em>, <em>Xvarnames</em>, <em>wh_keep</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.glm_multilevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict Y from X using GLM</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">stat</span><span class="p">]</span> <span class="o">=</span> <span class="n">glm_multilevel</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Yvarname</span><span class="p">,</span> <span class="n">Xvarnames</span><span class="p">,</span> <span class="n">wh_keep</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>Yvarname:</strong></dt>
<dd><p class="first last">the name of a variable to predict. must be event level</p>
</dd>
<dt><strong>Xvarnames:</strong></dt>
<dd><p class="first last">the name(s) of predictor variables. if multiple, put in
cell array. must be event level</p>
</dd>
<dt><strong>wh_keep:</strong></dt>
<dd><p class="first last">a logical vector of 1/0 values</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>b:</strong></dt>
<dd><p class="first last">a vector of coefficient estimates (same as for glmfit())</p>
</dd>
<dt><strong>dev:</strong></dt>
<dd><p class="first last">the deviance of the fit (same as for glmfit())</p>
</dd>
<dt><strong>stat:</strong></dt>
<dd><p class="first last">structure containing stats fields (see glmfit() documentation)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.histogram">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">histogram</code><span class="sig-paren">(</span><em>D</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.histogram" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Histogram of one variable in dataset</dt>
<dd><ul class="first last simple">
<li>can be either event-level or subject-level</li>
<li>event-level data is plotted as concatenated events across subject-level</li>
<li>both variables must be valid names (case-sensitive)</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>fig_han = histogram(D, [optional inputs]);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">canlab_dataset</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first"><a href="#id1"><span class="problematic" id="id2">**</span></a>nofig&#8217;: suppress creation of new figure</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig_han:</strong></dt>
<dd><p class="first last">figure handle</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.mediation">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">mediation</code><span class="sig-paren">(</span><em>D</em>, <em>xvarname</em>, <em>yvarname</em>, <em>mvarname</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.mediation" title="Permalink to this definition">¶</a></dt>
<dd><p>Run single or multilevel mediation analysis on a canlab_dataset object.
Calls mediation.m (see mediation.m) in mediation toolbox</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[paths, stats] = mediation(D, xvarname, yvarname, mvarname, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">is a canlab_dataset object</p>
</dd>
<dt><strong>xvarname:</strong></dt>
<dd><p class="first last">X, the initial variable (valid variable name in the dataset)</p>
</dd>
<dt><strong>yvarname:</strong></dt>
<dd><p class="first last">Y, the outcome variable (valid variable name in the dataset)</p>
</dd>
<dt><strong>mvarname:</strong></dt>
<dd><p class="first last">M, the potential mediator ((valid variable name in the dataset)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Takes any optional inputs to mediation.m
e.g., &#8216;noverbose&#8217;, &#8216;dosave&#8217;, &#8216;names&#8217;, &#8216;M&#8217;, &#8216;L2M&#8217;, &#8216;covs&#8217;, others</p>
<dl class="docutils">
<dt><strong>wh_keep:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by 1/0 vector of subjects to keep.</dt>
<dd><ul class="first last simple">
<li>must be same length as subjects</li>
<li>subjects with value 0 will be excluded</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>rankdata:</strong></dt>
<dd><p class="first last">ranks all data before mediation; &#8220;Nonparametric&#8221;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>paths:</strong></dt>
<dd><p class="first last">see mediation.m from mediation toolbox</p>
</dd>
<dt><strong>stats:</strong></dt>
<dd><p class="first last">see mediation.m from mediation toolbox</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">paths</span><span class="p">,</span> <span class="n">stats</span><span class="p">]</span> <span class="o">=</span> <span class="n">mediation</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;Group&#39;</span><span class="p">,</span> <span class="s">&#39;DeltaDon&#39;</span><span class="p">,</span> <span class="s">&#39;DeltaDist&#39;</span><span class="p">,</span> <span class="s">&#39;M2&#39;</span><span class="p">,</span> <span class="s">&#39;DeltaTend&#39;</span><span class="p">,</span> <span class="s">&#39;wh_keep&#39;</span><span class="p">,</span> <span class="n">wh_keep</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.plot_var">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">plot_var</code><span class="sig-paren">(</span><em>D</em>, <em>varname</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.plot_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the mean and standard error of a variable across events.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[meandat, stedat] = plot_var(D, varname, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>varname:</strong></dt>
<dd><dl class="first last docutils">
<dt>the name of a valid variable to get from dataset</dt>
<dd><p class="first last">-Looks for var name at either level, returns Event level if exists at both levels</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>subjtype:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by name of grouping variable</dt>
<dd><ul class="first last simple">
<li>must be categorical subject-level variable</li>
<li>if entered, plot lines or bars based on these categories</li>
<li>&#8216;eventmeans&#8217; will plot bars; without, it will plot line
plots across events with standard error shading</li>
<li>the grouping variable&#8217;s description, if it exists, will
be split along commas, and those values will be used as
column lables</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>eventmeans:</strong></dt>
<dd><dl class="first last docutils">
<dt>calculate and plot subject means across event-level variables</dt>
<dd><ul class="first last simple">
<li>if entered, will plot bar plots of means by condition</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>wh_keep:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by 1/0 vector of subjects to keep.</dt>
<dd><ul class="first last simple">
<li>must be same length as subjects</li>
<li>subjects with value 0 will be excluded</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>color:</strong></dt>
<dd><p class="first last">followed by one color for all bars, or cell array with names of colors cell for each line/bar</p>
</dd>
<dt><strong>nofig:</strong></dt>
<dd><p class="first last">don&#8217;t make a new figure</p>
</dd>
<dt><strong>other:</strong></dt>
<dd><p class="first last">other varargin are passed directly to barplot_columns.  So
for example, &#8216;95CI&#8217; will make 95% confidence interals, instead
of SE bars.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>meandat:</strong></dt>
<dd><p class="first last">mean values</p>
</dd>
<dt><strong>stedat:</strong></dt>
<dd><p class="first last">standard error values</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;Frustration&#39;</span><span class="p">)</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">)</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">,</span> <span class="s">&#39;eventmeans&#39;</span><span class="p">);</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">,</span> <span class="s">&#39;subjtype&#39;</span><span class="p">,</span> <span class="s">&#39;Placebo&#39;</span><span class="p">);</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">,</span> <span class="s">&#39;eventmeans&#39;</span><span class="p">,</span> <span class="s">&#39;subjtype&#39;</span><span class="p">,</span> <span class="s">&#39;Placebo&#39;</span><span class="p">);</span>
<span class="n">plot_var</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="s">&#39;RT&#39;</span><span class="p">,</span> <span class="s">&#39;eventmeans&#39;</span><span class="p">,</span> <span class="s">&#39;subjtype&#39;</span><span class="p">,</span> <span class="s">&#39;Placebo&#39;</span><span class="p">,</span> <span class="s">&#39;color&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;r&#39;</span> <span class="s">&#39;b&#39;</span><span class="p">});</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.print_summary">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">print_summary</code><span class="sig-paren">(</span><em>D</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.print_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints summaries for every variable, or specified variables</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>print_summary(D, [optional inputs]) 
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>subj:</strong></dt>
<dd><p class="first last">followed by a cell array of subject level var names, to only see those vars</p>
</dd>
<dt><strong>event:</strong></dt>
<dd><p class="first last">followed by a cell array of event level var names, to only see those vars</p>
</dd>
</dl>
<p class="last">if either varargin is unspecified, all variables will be printed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.read_from_excel">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">read_from_excel</code><span class="sig-paren">(</span><em>dat</em>, <em>ExperimentFileName</em>, <em>SubjectFileList</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.read_from_excel" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from datafile into canlab_dataset format - currently requires file
extensions .xls or .xlsx, but in the future will use importdata to take
.csv or .txt extensions as well.</p>
<dl class="docutils">
<dt>Datafiles require column headers</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Design file requires: id, names, units, descrip</dt>
<dd><ul class="first last">
<li><p class="first">other columns can be added</p>
</li>
<li><dl class="first docutils">
<dt>ONLY between subject columns identified in the &#8216;names&#8217;</dt>
<dd><p class="first last">column are added.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>See Sample_canlab_dataset_experiment_level.xlsx for an</dt>
<dd><p class="first last">example design file</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Subject files require no specific column headers, but all column</dt>
<dd><p class="first last">headers must be identical across all subjects.
- Enter NaN for data field in file if no value for that column within a specific Event
- ALL columns of subject files are written to canlab_dataset</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>dat = read_from_excel(dat, ExperimentFileName, SubjectFileList, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>ExperimentFileName:</strong></dt>
<dd><p class="first last">the absolute path of the experiment data file</p>
</dd>
<dt><strong>SubjectFileList:</strong></dt>
<dd><dl class="first last docutils">
<dt>list of absolute paths for individual subject files</dt>
<dd><ul class="first last simple">
<li>plays well with filenames()</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>fmri:</strong></dt>
<dd><p class="first last">Indicates construction of canlab_dataset object using &#8216;fmri&#8217;
code. Suppresses overwrite warnings specific to &#8216;fmri&#8217; inputs.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">canlab_dataset object with uploaded values</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% To output a file into a raw fmri dataset

DesignFile = fullfile(pwd,&#39;Sample_canlab_dataset_experiment_level.xlsx&#39;);
SubjectFiles = filenames(fullfile(pwd,&#39;Sample_canlab_dataset_subject*.xlsx&#39;));
dat = canlab_dataset(&#39;fmri&#39;);
dat = read_from_excel(dat,DesignFile,SubjectFiles,&#39;fmri&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.scattermatrix">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">scattermatrix</code><span class="sig-paren">(</span><em>D</em>, <em>wh_level</em>, <em>wh_vars</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.scattermatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Scatterplot matrix of pairwise event-level variables</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fig_han</span> <span class="o">=</span> <span class="n">scattermatrix</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">wh_level</span><span class="p">,</span> <span class="n">wh_vars</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>wh_level:</strong></dt>
<dd><p class="first last">1 (Subject) or 2 (Event)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fig_han:</strong></dt>
<dd><p class="first last">figure handle</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>fig_han = scattermatrix(D);

wh = [5:9];
fig_han = scattermatrix(D, 2, wh);

f = scattermatrix(D, 2, {&#39;Choice&#39; &#39;RT&#39; &#39;Pain&#39; &#39;SwitchNext&#39; &#39;Frustration&#39; &#39;Anxiety&#39; &#39;Control&#39;});
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.scatterplot">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">scatterplot</code><span class="sig-paren">(</span><em>D</em>, <em>v1</em>, <em>v2</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.scatterplot" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Scatterplot of two variables in dataset</dt>
<dd><ul class="first last simple">
<li>can be either event-level or subject-level</li>
<li>event-level data is plotted as multi-line plot, one line per subject</li>
<li>both variables must be valid names (case-sensitive)</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>fig_han = scatterplot(D, varname1, varname2, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>v1:</strong></dt>
<dd><p class="first last">x variable</p>
</dd>
<dt><strong>v2:</strong></dt>
<dd><p class="first last">y variable</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>nofig:</strong></dt>
<dd><p class="first last">suppress creation of new figure</p>
</dd>
<dt><strong>subjtype:</strong></dt>
<dd><p class="first last">group by the following variable name</p>
</dd>
<dt><strong>wh_keep:</strong></dt>
<dd><p class="first last">followed by logical</p>
</dd>
<dt><strong>colors:</strong></dt>
<dd><p class="first last">followed by colors.</p>
</dd>
<dt><strong>dorobust:</strong></dt>
<dd><p class="first last">do robust corr.  if enabled, colors will not work and subjtype grouping will not work well until
the function plot_correlation_samefig is updated, at some point in the future.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fig_han:</strong></dt>
<dd><p class="first last">figure handle</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>scatterplot(D, &#39;Anxiety&#39;, &#39;Frustration&#39;);
fig_han = scatterplot(D, D.Subj_Level.names{1}, D.Subj_Level.names{2});
scatterplot(D, D.Event_Level.names{1}, D.Event_Level.names{2});
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.spm2canlab_dataset">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">spm2canlab_dataset</code><span class="sig-paren">(</span><em>obj</em>, <em>subject</em>, <em>spm</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.spm2canlab_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract Event_Level data from subjects&#8217; SPM.mat files to add data to
canlab_dataset object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">spm2canlab_dataset</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span> <span class="n">spm</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">Canlab_dataset object (see canlab_dataset)</p>
</dd>
<dt><strong>subject:</strong></dt>
<dd><p class="first last">Subject list (it could be one subject [in a string 
format], or it could be multiple subjects in cell array)</p>
</dd>
<dt><strong>spm:</strong></dt>
<dd><p class="first last">This could be loaded SPM (struct), or one path for one 
subject&#8217;s SPM.mat file (string), or multiple loaded SPM or
paths in cell array</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">Canlab_dataset object with new data</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>subj = {&#39;dpsp002&#39;,&#39;dpsp003&#39;};
spm = {&#39;dpsp002_SPM.mat&#39;, &#39;dpsp003_SPM.mat&#39;};

D = canlab_dataset; % if D doesn&#39;t exist yet
D = spm2canlab_dataset(D, subj, spm);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">canlab_dataset
spm_mat2batchinput</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.ttest2">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">ttest2</code><span class="sig-paren">(</span><em>D</em>, <em>varname</em>, <em>wh_keep1</em>, <em>wh_keep2</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.ttest2" title="Permalink to this definition">¶</a></dt>
<dd><p>Two sample ttest for two samples of one subject-level variable</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>ttest2(D, varname, wh_keep1, wh_keep2, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
<dt><strong>varname:</strong></dt>
<dd><p class="first last">the name of a valid variable to get from dataset</p>
</dd>
<dt><strong>wh_keep1:</strong></dt>
<dd><p class="first last">subjects forming first sample</p>
</dd>
<dt><strong>wh_keep2:</strong></dt>
<dd><p class="first last">subjects forming second sample</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>noverbose:</strong></dt>
<dd><p class="first last">will suppress print out of results and bargraph</p>
</dd>
<dt><strong>varargin:</strong></dt>
<dd><p class="first last">other variables passed directly to MATLAB&#8217;s ttest2</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first last">same as MATLAB&#8217;s ttest2 output</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;canlab_dataset.write_text">
<code class="descclassname">&#64;canlab_dataset.</code><code class="descname">write_text</code><span class="sig-paren">(</span><em>D</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@canlab_dataset.write_text" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;Flatten&#8221; dataset and write text files with header and data
For all Event-level and Subject-level data.  Files are created in the
current working directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [headername, dataname, fid] = write_text(D, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>D:</strong></dt>
<dd><p class="first last">a canlab_dataset object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">the first varargin parameter is the delimiter. Comma-delimited by default.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>headername:</strong></dt>
<dd><p class="first last">filename of header output file</p>
</dd>
<dt><strong>dataname:</strong></dt>
<dd><p class="first last">filename of data output file</p>
</dd>
<dt><strong>fid:</strong></dt>
<dd><p class="first last">file ID (currently does not look to be used)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_data">
<span id="fmri-data"></span><h1>fmri_data<a class="headerlink" href="#module-@fmri_data" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_data.canlab_connectivity_preproc">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">canlab_connectivity_preproc</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.canlab_connectivity_preproc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function prepares data for connectivity analysis by removing nuisance
variables and temporal filtering (high, low, or bandpass filter). This also
can extract values from given masks and return averaged activity or pattern
expression values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">preprocessed_dat</span><span class="p">,</span> <span class="n">roi_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">canlab_connectivity_preproc</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><ul class="first last simple">
<li>can regress out nuisance variables with any additional nuisance matrix</li>
<li>can remove signal from ventricle and white matter (calls
canlab_extract_ventricle_wm_timeseries.m and canlab_create_wm_ventricle_masks.m)</li>
<li>can do temporal filtering, including high-pass, low-pass, or bandpass
filtering (it uses conn_filter.m from conn toolbox; see subfunction below)</li>
<li>can extract data from given ROIs, and return averaged value or pattern
expression value (dot-product).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><em>Steps in order [with defaults]:</em></dt>
<dd><ol class="first last arabic simple">
<li>Remove nuisance covariates (and linear trend if requested)</li>
<li>Remove ventricle and white matter - needs structural images</li>
<li>Windsorize based on distribution of full data matrix</li>
<li>High/low/bandpass filter</li>
<li>Extract region-by-region average ROI or pattern expression data</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">fmri_data object with data</p>
</dd>
<dt><strong>dat.covariate:</strong></dt>
<dd><p class="first last">basic nuisance matrix</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>additional_nuisance</strong></dt>
<dd><p class="first last">When you have additional nuisance variables that you want
regress out from the data, you can use this option. This
option should be followed by a nuisance matrix (or values).
The matrix should have the same number of rows with the
number of images.</p>
</dd>
<dt><strong>vw</strong></dt>
<dd><p class="first">When you want to regress out signals from ventricle and
white matter, you can use this option. To use this option,
You should provide the directory where the subjects&#8217; data
are saved using the &#8216;datdir&#8217; (for example, see below).
Requires specific subdirectory structure (CANlab) - see code.</p>
<p class="last">You can also choose what to use to remove ventricle and
white matter signal between raw data or top 5 PCA
components (default). You can just put &#8216;raw&#8217; if you want to
use raw signal than PCA compoenents.
also see: canlab_extract_ventricle_wm_timeseries.m
canlab_create_wm_ventricle_masks.m)
- <em>Example:</em> &#8216;vw&#8217;, &#8216;datdir&#8217;, subject_dir, &#8216;raw&#8217;</p>
</dd>
<dt><strong>windsorize:</strong></dt>
<dd><p class="first last">Windsorizing entire data matrix to k x STD.
- <em>Example:</em> &#8216;windsorize&#8217;, 5 (windsorize to 5 STD)</p>
</dd>
<dt><strong>linear_trend:</strong></dt>
<dd><p class="first last">This option will include the linear trend to nuisance variables.</p>
</dd>
<dt><strong>hpf&#8217;, &#8216;lpf&#8217;, or &#8216;bpf:</strong></dt>
<dd><p class="first">This option will do temporal filtering.
- &#8216;hpf&#8217;: high pass filter. This option should be followed by</p>
<blockquote>
<div><p>the lower bound of the frequency (e.g., .01 Hz [= 100 sec]).</p>
</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>&#8216;lpf&#8217;: low pass filter. This option should be followed by</dt>
<dd><p class="first last">the upper bound of the frequency (e.g., .25 Hz [= 4 sec]).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;bpf&#8217;: bandpass filter. This should be followed by lower</dt>
<dd><p class="first last">and upper bounds of the frequency (e.g., [.01 .25]).
After the frequency value, you need to provide TR.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>Example:</em> &#8216;hpf&#8217;, .01, TR</dt>
<dd><p class="first last">&#8216;bpf&#8217;, [.01 .25], TR</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>extract_roi:</strong></dt>
<dd><p class="first">This option will extract data from ROIs specified. This
option should be followed by one or more masks.
For one mask (potentially multiple ROIs, enter a char array with the mask name.
For multiple masks (1 or more), enter in a cell array of mask names.
You can specify methods with &#8216;roi_methods&#8217; option.
- &#8216;average_over&#8217; (default): calculate averaged value across the ROIs.
- &#8216;pattern_expression&#8217;: calculate dot-products between</p>
<blockquote>
<div><p>pattern mask and data</p>
</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>&#8216;unique_mask_values&#8217; (default): will divide a mask into</dt>
<dd><p class="first last">multiple regions that have different discrete values.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;contiguous_regions&#8217;: will divide a mask into multiple</dt>
<dd><p class="first last">contiguous regions.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;whole&#8217;: will do average_over or pattern_expression across</dt>
<dd><p class="first last">all the voxels within the mask.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>Example:</em> &#8216;extract_roi&#8217;, mask, &#8216;contiguous_regions&#8217;</dt>
<dd><p class="first last">&#8216;extract_roi&#8217;, mask, &#8216;pattern_expression&#8217;</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>no_preproc:</strong></dt>
<dd><p class="first last">If you want to skip the preprocessing part, and want to
extract ROI values only, you can use this option.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>preprocessed_dat:</strong></dt>
<dd><p class="first last">fmri_data object after removing nuisance variables and
filtering temporal confounds.</p>
</dd>
<dt><strong>roi_val:</strong></dt>
<dd><p class="first last">returns values extracted from ROIs in cell arrays (if there are many different ROIs).
Each cell will have roi_val.dat, roi_val.mask_name, and roi_val.methods.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>roi_masks = which(&#39;weights_NSF_grouppred_cvpcr.img&#39;);
[preprocessed_dat, roi_val] = canlab_connectivity_preproc(dat, &#39;vw&#39;, &#39;datdir&#39;,
       subject_dir, &#39;bpf&#39;, [.008 .25], TR, &#39;extract_roi&#39;, roi_masks, &#39;pattern_expression&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.create">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">create</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an object from an empty obj structure, assigning fieldname/value
pairs as optional arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[obj = create(obj, varargin)
</pre></div>
</div>
<p>Used in fmri_data.m class constructor.
if &#8216;noverbose&#8217; is entered, suppress output</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.extract_roi_averages">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">extract_roi_averages</code><span class="sig-paren">(</span><em>obj</em>, <em>mask_image</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.extract_roi_averages" title="Permalink to this definition">¶</a></dt>
<dd><p>This fmri_data method a extracts and averages data stored in an fmri_data object 
from a set of ROIs defined in a mask.</p>
<p>If no mask_image is entered, it uses the mask defined with the fmri_data object as a default.</p>
<dl class="docutils">
<dt>If mask_image is a new image file name, this method:</dt>
<dd><ol class="first last arabic simple">
<li>Defines an fmri_mask_image object using create_fmri_mask</li>
<li>Maps to the space in fmri_data object using resample_to_image_space</li>
</ol>
</dd>
</dl>
<p>Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)</p>
<p>Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.
NOTE: Mask is <em>reloaded</em> from original data if space is remapped, and you
cannot use manual thresholding of the mask. This is a feature of the
map_to_image_space method and scn_map_image</p>
<p>Extracted data is returned in single data format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[[cl, clroimean, clpattern] = extract_roi_averages(fmri_data obj, [mask_image], [average_over])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><ol class="first arabic simple">
<li>char array of strings containing 4D image file names (data extracted from these)</li>
<li>mask_image to extract from.</li>
</ol>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>how to average</strong></dt>
<dd><p class="first last">Default = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
bounded by voxels of 0 or NaN (non-data values)
(i.e., for atlas images with unique codes for each defined region)
Alt. option = &#8216;contiguous_regions&#8217; to average over contiguous voxels</p>
</dd>
<dt><strong>pattern_expression</strong></dt>
<dd><p class="first">Use values in mask images to get weighted average within each
region, rather than simple average.  See also apply_mask with
&#8216;pattern_expression&#8217; option.</p>
<p class="last">Optional outputs (varargout): 
[cl, cl_roimean, cl_roipattern] = ...
roimean: pattern expression is average over ROI (unit vector)
roipattern: pattern expression is dot product of activity and mean-centered pattern weights</p>
</dd>
<dt><strong>nonorm</strong></dt>
<dd><p class="first last">Turn off L1 norm in pattern expression.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">imgs_to_extract_from</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">(</span><span class="s">&#39;w*.nii&#39;</span><span class="p">,</span><span class="s">&#39;char&#39;</span><span class="p">);</span>
<span class="n">mask_image</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s">&#39;anat_lbpa_thal.img&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">cl</span><span class="p">,</span> <span class="n">clroimean</span><span class="p">,</span> <span class="n">clpattern</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_image_data</span><span class="p">(</span><span class="n">imgs_to_extract_from</span><span class="p">,</span> <span class="n">mask_image</span><span class="p">);</span>

<span class="n">region_obj</span> <span class="o">=</span> <span class="n">extract_roi_averages</span><span class="p">(</span><span class="n">data_obj</span><span class="p">,</span> <span class="n">mask_char_name</span><span class="p">,</span> <span class="s">&#39;pattern_expression&#39;</span><span class="p">,</span> <span class="s">&#39;contiguous_regions&#39;</span><span class="p">);</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Related functions:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">For an non-object-oriented alternative, see extract_image_data.m</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.horzcat">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">horzcat</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.horzcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the horzcat ([a b]) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function s = horzcat(varargin)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>c = [dat1 dat2];
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.hrf_fit">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">hrf_fit</code><span class="sig-paren">(</span><em>obj</em>, <em>TR</em>, <em>Runc</em>, <em>T</em>, <em>method</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.hrf_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>HRF estimation on fmri_data class object</p>
<p>HRF estimation function for a single voxel;</p>
<p>Implemented methods include: IL-model (Deterministic/Stochastic), FIR
(Regular/Smooth), and HRF (Canonical/+ temporal/+ temporal &amp; dispersion)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong></dt>
<dd><p class="first last">fMRI object</p>
</dd>
<dt><strong>TR</strong></dt>
<dd><p class="first last">time resolution</p>
</dd>
<dt><strong>Runs</strong></dt>
<dd><p class="first last">expermental design</p>
</dd>
<dt><strong>T</strong></dt>
<dd><p class="first last">length of estimated HRF ij seconds</p>
</dd>
<dt><strong>type</strong></dt>
<dd><p class="first last">Model type: &#8216;FIR&#8217;, &#8216;IL&#8217;, or &#8216;CHRF&#8217;</p>
</dd>
<dt><strong>mode</strong></dt>
<dd><p class="first last">Mode</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Model Types:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<ol class="upperalpha">
<li><dl class="first docutils">
<dt><strong>Fit HRF using IL-function</strong></dt>
<dd><dl class="first docutils">
<dt>Choose mode (deterministic/stochastic)</dt>
<dd><ul class="first last simple">
<li>0 - deterministic aproach</li>
<li>1 - simulated annealing approach</li>
</ul>
</dd>
</dl>
<p class="last">Please note that when using simulated annealing approach you
may need to perform some tuning before use.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Fit HRF using FIR-model</strong></dt>
<dd><dl class="first last docutils">
<dt>Choose mode (FIR/sFIR)</dt>
<dd><ul class="first last simple">
<li>0 - FIR</li>
<li>1 - smooth FIR</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>Fit HRF using FIR-model</strong></dt>
<dd><dl class="first last docutils">
<dt>Choose mode (FIR/sFIR)</dt>
<dd><ul class="first last simple">
<li>0 - FIR</li>
<li>1 - smooth FIR</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>SIMULATE DATA AND RUN</p>
<div class="highlight-python"><div class="highlight"><pre>%params for sim and fitting
TR = 2;   % repetition time (sec)
n = 200;  % time points measured (for simulation) must be multiple of 10
T = 30;   % duration of HRF to estimate (seconds)
nconds = 2; % num conditions
nevents = 8; % events per condition

% Create fake data
h = spm_hrf(TR);
y = zeros(n, 1);

% onsets - indicator
Condition = {};
for i = 1:nconds
    Condition{i} = zeros(n,1);
    wh = randperm(n);
    Condition{i}(wh(1:nevents)) = 1;

    ytmp{i} =  conv(Condition{i}, h);
    ytmp{i} = ytmp{i}(1:n);
end

y = sum(cat(2, ytmp{:}), 2);

dat = fmri_data(&#39;VMPFC_mask_neurosynth.img&#39;);  % AVAILABLE ON WIKI IN MASK GALLERY
dat = threshold(dat, [5 Inf], &#39;raw-between&#39;);

v = size(dat.dat, 1); % voxels in mask
dat.dat = repmat(y&#39;,v, 1) + .1 * randn(v, n);

% Fit data - estimate HRFs across the brain mask
[params_obj hrf_obj] = hrf_fit(dat,TR, Condition, T,&#39;FIR&#39;, 1);

hrf = fmri_data(&#39;HRF_timecourse_cond0001.img&#39;);
hrf = remove_empty(hrf);
create_figure(&#39;hrfs&#39;, 1, 2); 
plot(hrf.dat&#39;);
title(&#39;Condition 1&#39;)
hrf = fmri_data(&#39;HRF_timecourse_cond0002.img&#39;);
hrf = remove_empty(hrf);
subplot(1, 2, 2);
plot(hrf.dat&#39;);
title(&#39;Condition 2&#39;)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.plot">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>fmridat</em>, <em>plotmethod</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot means by condition
plot(fmri_data_object, &#8216;means_for_unique_Y&#8217;)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt>Plot methods:</dt>
<dd><ul class="first last simple">
<li>plot data matrix</li>
<li>plot(fmri_data_object)</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">fmridat</span><span class="p">,</span> <span class="p">[</span><span class="n">plotmethod</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>5 plots and an SPM orthviews presentation of the data.  In the below 
and elsewhere, &#8220;image&#8221; connotes a 3D brain volume captured every TR.</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>subplot 1:</strong></dt>
<dd>the fMRI data itself. Color is intensity of signal.</dd>
<dt><strong>subplot 2:</strong></dt>
<dd>presented as a histogram of values for every voxel collected.
The low values are typically out-of-brain voxels, as there is
no signal there.</dd>
<dt><strong>subplot 3:</strong></dt>
<dd>each point is an image.  The point&#8217;s X value is the mean
intensity of every voxel in that image, and the Y value is the
stdev of intensities for all voxels in that image.</dd>
<dt><strong>subplot 4:</strong></dt>
<dd>covariance between images</dd>
<dt><strong>subplot 5:</strong></dt>
<dd>each point is an image (case = image).  X value is image
number in the run, Y is image mean intensity, and the size of
the circular marker represents stdev for that image</dd>
<dt><strong>Orthviews:</strong></dt>
<dd>mean and STD for a given voxel averaged over time.  Note that
the values for mean and STD here are higher than in the plots
above. That is because mean and STD are calculated here by
voxel, but in the plots above they are calculated by image.
Images also include out-of-brain areas.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.predict">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">predict</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict outcome (Y) from brain data and test cross-validated error rate for an fmri_data object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">cverr</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">optional_outputs</span><span class="p">]</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><ul class="first simple">
<li>flexible specification of algorithm by function name</li>
<li>k-fold cross-validation, default = 5-fold, can enter custom fold membership</li>
<li>folds are stratified on outcome</li>
<li>choice of multiple error metrics (class loss, mse, etc.)</li>
<li>by default, chooses error metric based on outcome type (classes vs. continuous-valued)</li>
<li>returns all outputs for each fold returned by the algorithm in optout cell array variable</li>
<li>bootstrapping of weights built in [optional keyword]</li>
<li>select variable number of components (for pcr-based techniques)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Inputs:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>obj is mandatory, rest are optional</dt>
<dd><dl class="first last docutils">
<dt><strong>obj:</strong></dt>
<dd>fmri_data or image_vector object, with fields .dat (data used to predict) and .Y (outcome)</dd>
</dl>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><p class="first">(with their default values)</p>
<dl class="docutils">
<dt><strong>nfolds</strong> = 5</dt>
<dd><p class="first last">number of folds</p>
</dd>
<dt><strong>nfolds</strong> = [vector of integers]</dt>
<dd><p class="first last">can also input vector of integers for holdout set IDs</p>
</dd>
<dt><strong>error_type</strong> = mcr</dt>
<dd><p class="first last">mcr, mse: misclassification rate or mean sq. error</p>
</dd>
<dt><strong>algorithm_name</strong> = &#8216;cv_regress&#8217;</dt>
<dd><p class="first last">name of m-file defining training/test function</p>
</dd>
<dt><strong>useparallel</strong> = 1</dt>
<dd><p class="first last">Use parallel processing, if available; follow by 1 for yes, 0 for no</p>
</dd>
<dt><strong>bootweights</strong> = 0</dt>
<dd><p class="first last">bootstrap voxel weights; enter bootweights do bootstrapping of weight maps (based on all observations)</p>
</dd>
<dt><strong>savebootweights</strong></dt>
<dd><p class="first last">save bootstraped weights (useful for combining across multiple iterations of predict())</p>
</dd>
<dt><strong>bootsamples</strong> = 100</dt>
<dd><p class="first last">number of bootstrap samples to use</p>
</dd>
<dt><strong>numcomponents</strong> = xxx:</dt>
<dd><p class="first last">save first xxx components (for pca-based methods)</p>
</dd>
<dt><strong>nopcr</strong></dt>
<dd><p class="first last">for cv_lassopcr and cv_lassopcrmatlab: do not do pcr, use original variables</p>
</dd>
<dt><strong>lasso_num</strong> = xxx</dt>
<dd><p class="first last">followed by number of components/vars to retain after shrinkage</p>
</dd>
<dt><strong>hvblock</strong> = [h,v]</dt>
<dd><p class="first last">use hvblock cross-validation with a block size of &#8216;h&#8217; (0 reduces to v-fold xval) and
number of test observations &#8216;v&#8217; (0 reduces to h-block xval)</p>
</dd>
<dt><strong>rolling</strong> = [h,v,g]</dt>
<dd><p class="first last">use rolling cross-validation with a block size of &#8216;h&#8217; (0 reduces to v-fold xval) and
number of test observations &#8216;v&#8217; (0 reduces to h-block xval), and a training size
of g * 2 surrounding hv</p>
</dd>
<dt><strong>verbose</strong> = 1</dt>
<dd><p class="first last">Set to 0 to suppress output to command window</p>
</dd>
<dt><strong>platt_scaling</strong></dt>
<dd><p class="first last">calculate cross-validated platt scaling if using SVM.
Softmax parameters [A,B] are in other_output{3}</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Algorithm choices:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">You can input the name (as a string array) of any algorithm with the
appropriate inputs and outputs. i.e., this can either be one of the
built-in choices below, or the name of another m-file.
The format for algorithm functions is :
[yfit, other_outputs] = predfun(xtrain, ytrain, xtest, optional_inputs)
Each algorithm can take/interpret its own optional inputs.
For bootstrapping of weights, algorithms MUST RETURN 3 OUTPUTS
(programming &#8216;feature&#8217;)</p>
<p>To choose an algorithm, enter &#8216;algorithm_name&#8217; followed by a text string
with a built-in algorithm name, or a function handle for a custom algorithm
Built-in algorithm choices include:</p>
<dl class="docutils">
<dt><strong>cv_multregress:</strong></dt>
<dd><p class="first last">[default] multiple regression</p>
</dd>
<dt><strong>cv_univregress:</strong></dt>
<dd><p class="first last">Average predictions from separate univariate regression of outcome on each feature</p>
</dd>
<dt><strong>cv_svr:</strong></dt>
<dd><p class="first last">Support vector regression with Spider package; requires spider</p>
</dd>
<dt><strong>cv_pcr:</strong></dt>
<dd><p class="first last">Cross-validated principal components regression</p>
</dd>
<dt><strong>cv_lassopcr:</strong></dt>
<dd><p class="first last">Cross-val LASSO-PCR; can enter &#8216;lasso_num&#8217; followed by components to retain by shrinkage
NOTE: can enter &#8216;EstimateParams&#8217; to use shrankage
lasso method based on the estimated optimal lambda
that minimizes the mean squared error (MSE) of nested
cross-validation models. Output of nested cv model is
saved in stats.other_output_cv{:,3}. Output includes
&#8216;Lambda&#8217; parameter and min MSE value.</p>
</dd>
<dt><strong>cv_lassopcrmatlab:</strong></dt>
<dd><p class="first last">Cross-val LASSO-PCR; can enter &#8216;lasso_num&#8217; followed by components to retain by shrinkage
NOTE: this uses the matlab implementation of LASSO,
but can also run ridge or elastic net. Reduces to PCR
when no lasso_num is entered by default.  Use MSE for
predicting continuous data and MCR for classifying
binary data.
NOTE: You can input any optional inputs that lassoglm
takes.
Enter &#8216;Alpha&#8217;, (0,1] as optional inputs to
run ridge (Alpha approaches 0, but excluding 0), lasso (Alpha = 1), or elastic
net (Alpha between 0 and 1)
NOTE: Requires Matlab R2012a and higher.
NOTE: Optional input: &#8216;EstimateParams&#8217; - this will
use grid search and nested cross validation to
estimate Lambda and Alpha.  Output is saved in
stats.other_output_cv{:,3}.  Output includes &#8216;Alpha&#8217;
parameter which is the elastic net mixture value
between l1 and l2 regularization, &#8216;Lambda&#8217; parameter,
which is amount of LASSO regularization/shrinkage, and
&#8216;errorMatrix&#8217;, which is the amount of error for each
parameter combination.  Use
imagesc(obj.stats_other_output_cv{:,3}.errorMatrix)
to view matrix.  Min of this matrix is the best
fitting parameters.</p>
</dd>
<dt><strong>cv_svm:</strong></dt>
<dd><p class="first last">Cross-val support vector machine using Spider package
NOTE: This is sensitive to scale of outputs! Use -1 , 1
NOTE: Optional inputs: Slack var parameter: &#8216;C&#8217;, 1 [default], &#8216;C&#8217;, 3 etc.
Distance from hyperplane saved in
stats.other_output_cv{:,2}.  Recommend using the reordered
cross-validated distance from hyperplane saved in stats.other_output{3}
stats.dist_from_hyperplane_xval =  cross-validated distance from hyperplane
stats.weight_obj = voxel (variable) weight object
e.g., orthviews(stats.weight_obj)
Intercept for calculating dist from hy is in stats.other_output_cv{:,3}
e.g., dist_hy = stats.weight_obj.dat&#8217; * obj.dat, where obj is a new set of test images
NOTE: To run nonlinear SVM using radial basis
function.  Add &#8216;rbf&#8217; followed by size of sigma (e.g., 2).
NOTE: To estimate some of the parameters using
nested cross validation add &#8216;EstimateParams&#8217; as optional input.
NOTE: To run multiclass SVM (i.e., one vs rest) add
&#8216;MultiClass&#8217; as optional input.  Important - Obj.Y must be a matrix (data x
class) with a column of 1 and -1 indicating each
class.  For example, if using 3 classes, then obj.Y
must have 3 columns.
NOTE: To run a balanced SVM where the number of cases for each class are unequal (i.e., one vs rest) add
&#8216;Balanced&#8217; as optional input, followed by a numerical value indicating the ridge amount (e.g., 0.01).</p>
</dd>
<dt><strong>cv_multilevel_glm:</strong></dt>
<dd><p class="first last">Runs glmfit_multilevel. Must pass in &#8216;&#8217;subjIDs&#8217;&#8217; followed by an array specifying which subject each trial belongs to
Subjects&#8217; trials must all be &#8220;adjacent&#8221;, i.e., don&#8217;t
put some of subject 1&#8217;s trials at the beginning and
other trials at the end &#8211; subjIDs does not handle
this case correctly. Also, 2ND LEVEL PREDICTORS NOT
CURRENTLY SUPPORTED.  code can be expanded to support this.
mean-centering X and/or Y will NOT impact the
predictor betas.  Note that it WILL impact the intercept
esimate as well as how much variance is explained
(pred_outcome_r).  Stratified CV partition not
supported either, pass in custom holdout set.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Y:</strong></dt>
<dd><p class="first last">Copy of outcome data to be predicted</p>
</dd>
<dt><strong>algorithm_name:</strong></dt>
<dd><p class="first last">Name of algorithm; see options above</p>
</dd>
<dt><strong>function_call:</strong></dt>
<dd><p class="first last">String of the command evaluated to call the prediction function</p>
</dd>
<dt><strong>function_handle:</strong></dt>
<dd><p class="first last">Handle for the command evaluated to call the prediction function</p>
</dd>
<dt><strong>yfit:</strong></dt>
<dd><p class="first last">Predicted outcome data (cross-validated)</p>
</dd>
<dt><strong>err:</strong></dt>
<dd><p class="first last">Residuals/misclassification vector (cross-validated)</p>
</dd>
<dt><strong>error_type:</strong></dt>
<dd><p class="first last">Name of error metric used for cverr</p>
</dd>
<dt><strong>cverr:</strong></dt>
<dd><p class="first last">Cross-validated error</p>
</dd>
<dt><strong>nfolds:</strong></dt>
<dd><p class="first">Number of folds in stratified cross-validation, or
vector of integers for membership in custom holdout set of each fold</p>
<blockquote class="last">
<div><ul class="simple">
<li>if k = 1, will estimate weights for full data object
and not crossvalidate (useful for bootstrapping)</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>cvpartition:</strong></dt>
<dd><p class="first last">Cross-val partition object or structure with fold info</p>
</dd>
<dt><strong>teIdx:</strong></dt>
<dd><p class="first last">Cell array of logical vectors with test samples in each fold</p>
</dd>
<dt><strong>trIdx:</strong></dt>
<dd><p class="first last">Cell array of logical vectors with training samples in each fold</p>
</dd>
<dt><strong>other_output:</strong></dt>
<dd><p class="first last">Other outputs returned by the algorithm; number and nature depend on algo choice; e.g., beta weights, svr weights, etc.
For many algorithms, other_output{1} is a vector of
weights on variables (e.g., voxels)</p>
</dd>
<dt><strong>other_output_descrip:</strong></dt>
<dd><p class="first last">String description of other outputs</p>
</dd>
<dt><strong>other_output_cv:</strong></dt>
<dd><p class="first last">Other outputs for each cross-validation fold</p>
</dd>
<dt><strong>other_output_cv_descrip:</strong></dt>
<dd><p class="first last">Other output from algorithm - for each CV fold</p>
</dd>
<dt><strong>mse:</strong></dt>
<dd><p class="first last">For regression only; mean squared error</p>
</dd>
<dt><strong>rmse:</strong></dt>
<dd><p class="first last">For regression only; root mean squared error</p>
</dd>
<dt><strong>meanabserr:</strong></dt>
<dd><p class="first last">For regression only; mean absolute error</p>
</dd>
<dt><strong>pred_outcome_r:</strong></dt>
<dd><p class="first last">For regression only; prediction-outcome correlation</p>
</dd>
<dt><strong>WTS:</strong></dt>
<dd><p class="first last">bootstrapped weights on voxels</p>
</dd>
<dt><strong>weight_obj:</strong></dt>
<dd><p class="first last">for some algorithms, an fmri_data object with the predictive weights (from full sample)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = fmri_data;
obj.dat = randn(30, 50); %    30 voxels, 50 images (observations)
obj.Y = obj.dat&#39; * rand(30, 1) + randn(50, 1); %    toy Y, linear combo of X plus noise
[cverr, stats, regression_outputs] = predict(obj);

Simulated example with 100 observations, 1000 voxels, with bootstrapping
dat = fmri_data;
dat.Y = rand(100, 1);
dat.dat = repmat(dat.Y&#39;, 1000, 1) + 10*rand(1000, 100);
[err,stats] = predict(dat, &#39;bootweights&#39;, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;);

[cverr, stats, regression_outputs] = predict(obj, &#39;nfolds&#39;, 3, &#39;error_type&#39;, &#39;meanabserr&#39;);
[cverr, stats, regression_outputs] = predict(obj, &#39;algorithm_name&#39;, &#39;cv_univregress&#39;, &#39;error_type&#39;, &#39;meanabserr&#39;);
[cverr, stats, optout] = predict(obj, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;lasso_num&#39;, 5, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;, &#39;bootweights&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;rbf&#39;, 2, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;); %SVM w/ radial basis function
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;rbf&#39;, 2, &#39;EstimateParams&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;); %SVM w/ radial basis function w/ parameters estimated using nested cross-valdiation
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_svm&#39;, &#39;nfolds&#39;, 5, &#39;MultiClass&#39;, &#39;error_type&#39;, &#39;mse&#39;);

Elastic net with first 10 components:
[cverr, stats, optout] = predict(dat_masked, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;, &#39;numcomponents&#39;, 10, &#39;Alpha&#39;, .5); stats.pred_outcome_r

Ridge with first 10 components:
[cverr, stats, optout] = predict(dat_masked, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, 5, &#39;error_type&#39;, &#39;mse&#39;, &#39;numcomponents&#39;, 10, &#39;Alpha&#39;, 0.00001); stats.pred_outcome_r

Lasso with all components, but shrink to retain 2 components only:
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, whfolds, &#39;nopcr&#39;, &#39;lasso_num&#39;, 2, &#39;Alpha&#39;, 1);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, whfolds, &#39;lasso_num&#39;, 2);

Lasso with the shrinkage methods based on the estimated optimal lambda that minimizes MSE of nested cross-validation models.
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, whfolds, &#39;estimateparam&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, 5, &#39;estimateparam&#39;);

Lasso without doing PCR:
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcrmatlab&#39;, &#39;nfolds&#39;, whfolds, &#39;nopcr&#39;, &#39;lasso_num&#39;, 2, &#39;Alpha&#39;, 1);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, whfolds, &#39;lasso_num&#39;, 2, &#39;nopcr&#39;);
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;nfolds&#39;, 5, &#39;estimateparam&#39;, &#39;nopcr&#39;);

Lasso pcr using hvblock cross-validation on time-series, h = 3, v = 5;
[cverr, stats, optout] = predict(dat, &#39;algorithm_name&#39;, &#39;cv_lassopcr&#39;, &#39;hvblock&#39;,[3,5]);

Output display:
orthviews(stats.weight_obj)
line_plot_multisubject(stats.yfit, stats.Y, &#39;subjid&#39;, id_numbers);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"><p class="first">predict_test_suite method for fmri_data, which runs predict with multiple
options and summarizes output.</p>
<p class="last">xval_regression_multisubject, xval_lasso_brain</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.predict_test_suite">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">predict_test_suite</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.predict_test_suite" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a set of cross-validated prediction algorithms on an fmri_data object
and plot the outcome.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[allcverr, allyhat] = predict_test_suite(dat, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Functionality:</th><td class="field-body"><ul class="first simple">
<li>Requires matlab 2012a or later for full functionality</li>
<li>Handles categorical or continuous outcomes automatically</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">an fMRI data object. 
dat.Y must be assigned, and must have continuous or binary outcomes assigned.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Optional:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><strong>quick:</strong></dt>
<dd>Skip extended output</dd>
<dt><strong>nfolds:</strong></dt>
<dd>Followed by number of folds or custom holdout vector (default = 5-fold balanced)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">predict_test_suite</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;nfolds&#39;</span><span class="p">,</span> <span class="n">subjid</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.regress">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">regress</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.regress" title="Permalink to this definition">¶</a></dt>
<dd><p>Regression method for fmri_data object</p>
<p>Regress dat.X on dat.dat at each voxel, and return voxel-wise statistic
images. Each column of dat.X is a predictor in a multiple regression,
and the intercept is the last column. Intercept will automatically be
added if not detected unless &#8216;nointercept&#8217; is specified.</p>
<p>This function can also create a map of brain regions that predict the dat.Y
vector using the &#8216;brainony&#8217; option.  This is essentially a univariate
version of the &#8216;predict&#8217; command.  Warning: this is very slow as it loops
through all voxels.</p>
<p>Regression is OLS by default, but can be robust using &#8216;robust&#8217; flag.</p>
<p>Creates thresholded plot by default</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">regress</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">should be an fmri_data object with X field defined.
dat.X can be a design_matrix() object.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>[threshold, &#8216;unc&#8217;]:</strong></dt>
<dd><p class="first last">p-value threshold string indicating threshold type
(see help statistic_image.threshold for options)</p>
</dd>
<dt><strong>nointercept:</strong></dt>
<dd><p class="first last">Do not add intercept to model</p>
</dd>
<dt><strong>nodisplay:</strong></dt>
<dd><p class="first last">Do not plot thresholded results using orthviews</p>
</dd>
<dt><strong>brainony:</strong></dt>
<dd><p class="first last">univariate approach to predict obj.Y from brain data</p>
</dd>
<dt><strong>residual:</strong></dt>
<dd><p class="first last">Output residual as fmri_data() object</p>
</dd>
<dt><strong>noverbose:</strong></dt>
<dd><p class="first last">Suppress verbose outputs</p>
</dd>
<dt><strong>robust:</strong></dt>
<dd><p class="first last">Run a robust regression (default is OLS).  Robust is considerably
slower than OLS</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>out:</strong></dt>
<dd><p class="first last">A structure containing stats_img and fmri_data objects.</p>
</dd>
<dt><strong>out.b:</strong></dt>
<dd><p class="first last">stats_img object of beta values estimated from regression</p>
</dd>
<dt><strong>out.t:</strong></dt>
<dd><p class="first last">stats_img object of t-values with input threshold</p>
</dd>
<dt><strong>out.df:</strong></dt>
<dd><p class="first last">fmri_data object of degrees of freedom</p>
</dd>
<dt><strong>out.sigma:</strong></dt>
<dd><p class="first last">fmri_data object of variance of residual</p>
</dd>
<dt><strong>out.residual:</strong></dt>
<dd><p class="first last">fmri_data object of residual data after model has been regressed out (optional).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Run regression with liberal threshold
out = regress(dat, .05, &#39;unc&#39;);

% Run regression with conservative threshold and save residual
out = regress(dat, .001, &#39;unc&#39;, &#39;residual);

% Run robust regression with fdr threshold
out = regress(dat, .05, &#39;fdr&#39;,&#39;robust&#39;);

% Run a regression predicting behavior from brain at liberal threshold
out  = regress(data_comb, .05, &#39;unc&#39;, &#39;brainony&#39;)

% Re-threshold at different values
out.t = threshold(out.t, .05, &#39;fdr&#39;);
out.t = threshold(out.t, .001, &#39;unc&#39;);

% Re-display results of thresholding
orthviews(out.t);

% Write out beta image to current directory
out.b.fullpath = fullfile(pwd,&#39;beta.nii&#39;);
write(out)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.rescale">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">rescale</code><span class="sig-paren">(</span><em>fmridat</em>, <em>meth</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>Rescales data in an fmri_data object
Data is observations x images, so operating on the columns operates on
images, and operating on the rows operates on voxels (or variables more
generally) across images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fmridat</span> <span class="o">=</span> <span class="n">rescale</span><span class="p">(</span><span class="n">fmridat</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Methods:</strong></dt>
<dd><ul class="first last simple">
<li>centervoxels</li>
<li>zscorevoxels</li>
<li>centerimages</li>
<li>zscoreimages</li>
<li>rankvoxels</li>
<li>windsorizevoxels</li>
<li>percentchange</li>
<li>tanh</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Appropriate for multi-session (time series) only:</dt>
<dd><ul class="first last simple">
<li>session_global_percent_change</li>
<li>session_global_z</li>
<li>session_multiplicative</li>
</ul>
</dd>
</dl>
<p>See also fmri_data.preprocess</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.saveplots">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">saveplots</code><span class="sig-paren">(</span><em>fmri_dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.saveplots" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dir</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.signtest">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">signtest</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.signtest" title="Permalink to this definition">¶</a></dt>
<dd><p>Sign test for each voxel of an fmri_data object
returns voxel-wise statistic images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[out, statimg] = signtest(dat, [p-val threshold], [thresh_type])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">Should be an fmri_data object with .dat field containing voxels x observations matrix</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">in [  ] above are
<strong>p-value threshold:</strong></p>
<blockquote>
<div><p>string indicating threshold type (see help statistic_image.threshold for options)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out:</strong></dt>
<dd><p class="first last">is a structure of information about the sign test</p>
</dd>
<dt><strong>statimg:</strong></dt>
<dd><blockquote class="first">
<div><p>is a statistic_image object that can be thresholded and
plotted/imaged.  statimg.dat contains signed direction values,</p>
</div></blockquote>
<p class="last">.p contains p-values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>c Tor Wager, 2011
..</p>
<p>See also: fmri_data.regress</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.ttest">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">ttest</code><span class="sig-paren">(</span><em>fmridat</em>, <em>pvalthreshold</em>, <em>thresh_type</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.ttest" title="Permalink to this definition">¶</a></dt>
<dd><p>T-test on fmri_data class object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">statsimg</span> <span class="o">=</span> <span class="n">ttest</span><span class="p">(</span><span class="n">fmridat</span><span class="p">,</span> <span class="n">pvalthreshold</span><span class="p">,</span> <span class="n">thresh_type</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>p-value threshold:</strong></dt>
<dd><p class="first last">p-value, e.g., .05 or .001 or [.001 .01 .05]</p>
</dd>
<dt><strong>thresh_type:</strong></dt>
<dd><p class="first last">&#8216;uncorrected&#8217;, &#8216;fwe&#8217;, or &#8216;fdr&#8217;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>%T-test, Construct a stats_image object, threshold and display:
statsimg = ttest(fmridat, .001, &#39;unc&#39;);
orthviews(statsimg);

%Re-threshold and display:
statsimg = threshold(statsimg, .000001, &#39;unc&#39;);
orthviews(statsimg);

statsimg = threshold(statsimg, .01, &#39;fdr&#39;);
orthviews(statsimg);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">for two-sample T-test, use fmri_data.regress</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_data.windsorize">
<code class="descclassname">&#64;fmri_data.</code><code class="descname">windsorize</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_data.windsorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Windsorize an fMRI data object to madlimit Median Absolute Deviations.
Default = 5 MADs.
Works across rows and columns.
Registers this step in history.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">windsorize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">[</span><span class="n">madlimit</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_mask_image">
<span id="fmri-mask-image"></span><h1>fmri_mask_image<a class="headerlink" href="#module-@fmri_mask_image" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_mask_image.resample_to_image_space">
<code class="descclassname">&#64;fmri_mask_image.</code><code class="descname">resample_to_image_space</code><span class="sig-paren">(</span><em>obj</em>, <em>sampleto</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_mask_image.resample_to_image_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples data in an fmri_mask_image object (obj) to the space of another
image (e.g., a functional image, for data extraction)
The volInfo field will be the same as the sampleto volume info.
The mask will have zeros in obj.dat for out-of-mask voxels.
THIS FUNCTION USES SCN_MAP_IMAGE AND REQUIRES THAT THE ORIGINAL IMAGE BE
AVAILABLE ON DISK.  Multiple resamplings will break the function because
the new space will be different from the original one on disk.  Use the
more general resample_space.</p>
<p>NOTE: Mask is <em>reloaded</em> from original data if space is remapped, and you
cannot use manual thresholding of the mask. This is a feature of the
map_to_image_space method and scn_map_image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = resample_to_image_space(obj, sampleto &lt;img name or image_vector object&gt;)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">must be an fmri_mask_image object</p>
</dd>
<dt><strong>sampleto:</strong></dt>
<dd><dl class="first last docutils">
<dt>can be either:</dt>
<dd><ol class="first last arabic simple">
<li>An image name to sample to</li>
<li>Another fmri_mask_image object (but image must exist on path!)</li>
</ol>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>mask:</strong></dt>
<dd><p class="first last">Apply sampleto as mask so that only voxels in the sampleto mask
are retained in obj.dat.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>THIS FUNCTION WORKS, BUT IS DEPRECATED BECAUSE RESAMPLE_SPACE IS MORE
GENERAL.  resample_space does not require the resampling of the original
image from disk, which this does.  resample_space is slower, though.</p>
<p>See Also: resample_space, for a method that does not require images to
exist on disk on the path.</p>
</dd></dl>

</div>
<div class="section" id="module-&#64;fmri_model">
<span id="fmri-model"></span><h1>fmri_model<a class="headerlink" href="#module-@fmri_model" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;fmri_model.build">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">build</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the design matrix (xx) for an fmri_model object</p>
<p>We assume that the same conditions are modeled for each session.
We assume that you have one basis set per condition (this is different
from SPM, which only allows a single basis set across all conditions)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">fmri_model_obj</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.build_single_trial">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">build_single_trial</code><span class="sig-paren">(</span><em>obj</em>, <em>inputhrf</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.build_single_trial" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a single-trial design matrix (xx) for an fmri_model object</p>
<p>We assume that the same conditions are modeled for each session
We assume that you have one basis set per condition (this is different
from SPM, which only allows a single basis set across all conditions)</p>
<p>This is used in single_trial_estimates, which assumes that you have
estimated an initial model and saved image data.</p>
<p>The idea behind this is somewhat different from other canlab single-trial
analyses, in that it takes in a single, custom HRF for each condition,
rather than using a basis set.  In single_trial_estimates, custom HRFs
are created for each voxel by using the condition- and voxel-specific hrf
estimates stored during model fitting.</p>
<dl class="docutils">
<dt>The sequence would be:</dt>
<dd><ol class="first last arabic simple">
<li>robustfit(my_model), to fit average model and get HRF est for each
voxel</li>
<li>single_trial_estimates(my_model), to use this function to build
single-trial design matrices and fit them.</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">build_single_trial</span><span class="p">(</span><span class="n">fmri_model_obj</span><span class="p">,</span> <span class="n">inputhrf</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inputhrf:</strong></dt>
<dd><p class="first last">should be a cell array of length nconds (number of conditions).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.get_condition_assignments">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">get_condition_assignments</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.get_condition_assignments" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Condition assignments</dt>
<dd><ul class="first last simple">
<li>Indicator matrix coding for which columns in X belong to the same
modeled condition, and are part of the same HRF fit</li>
<li>There is one set of columns for each condition modeled, and one set of
columns for each parametric modulator of each condition</li>
<li>Because parametric modulators may not exist for all conditions, we need
to build this dynamically for modulators.</li>
</ul>
</dd>
</dl>
<p>Design matrix build (which calls method get_session_X) builds columns in
this order:</p>
<p>All within Session:
Regressors of interest, basis functions within conditions
Parametric modulators, basis functions within conditions
Covariates of no interest</p>
<p>Then:
Baselines (session/run intercepts)</p>
<p>This method is called automatically in the build method.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.get_session_X">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">get_session_X</code><span class="sig-paren">(</span><em>obj</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.get_session_X" title="Permalink to this definition">¶</a></dt>
<dd><p>Get design matrix (predictors) for one session of fmri_model object, using
basis functions defined in the object and onsets for one session (s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[Xs, delta, C, B, names] = get_session_X(obj, session number)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.plot">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">plot</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot an fmri_model object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.replace_basis_set">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">replace_basis_set</code><span class="sig-paren">(</span><em>obj</em>, <em>condition_num</em>, <em>xBF_hires</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.replace_basis_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace a basis set in an fmri_model object with another one of your
choosing.</p>
<p>This allows one to use a custom basis set, and also to use different
basis sets for different trial types.</p>
<p>Each condition across all sessions must be modeled with the same basis
set. That is, there can be only one basis set per condition, e.g., one
for anticipation (used in each session) and one for pain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">replace_basis_set</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">condition_num</span><span class="p">,</span> <span class="n">xBF_hires</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% generate a custom spline basis set and use that for Condition 1,
% and the standard one for Condition 2:

[xBF_hires, xBF] = fmri_spline_basis(2, &#39;length&#39;, 12, &#39;nbasis&#39;, 3, &#39;order&#39;, 3, &#39;plot&#39;);

%save this to get info that is not typically in basis set until after
%model is built.
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.robustfit">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">robustfit</code><span class="sig-paren">(</span><em>fmri_model_obj</em>, <em>fmri_data_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.robustfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Robust fit for a model object to data object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>robustfit(fmri_model_obj, fmri_data_obj, [optional args])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><p class="first">spatial smoothing of weights at 12 mm FWHM
ridge regression <strong>*not yet*</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Preproc scaling:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ol class="first arabic simple">
<li>Remove covariates using ridge reg; ridge trace for full model</li>
<li>scale to % signal change across time (cols) OR rank time points (for
w/i ss predictions??) AND/OR rank or center rows (images; for &#8216;shape&#8217;
analysis</li>
</ol>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"><p class="first">%sig across time, rank across rows: relative % sig change</p>
<p>Different models of noise lead to different ideas about optimal preproc
If large diffs in nuisance scaling in BOLD across individuals, ranking cols may
be good idea. but then individual diffs in overall activity will be removed...</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Options:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tune:</strong></dt>
<dd><p class="first last">tuning const for robust reg</p>
</dd>
<dt><strong>iter:</strong></dt>
<dd><p class="first last">&#8216;maxiterations&#8217;, robust reg /WLS iterations. 1 = OLS only!</p>
</dd>
<dt><strong>smooth:</strong></dt>
<dd><p class="first last">&#8216;spatial_smooth_fwhm&#8217;, 0 or smoothing kernel for weights</p>
</dd>
<dt><strong>nosmooth:</strong></dt>
<dd><p class="first last">spatial_smooth_fwhm = 0;</p>
</dd>
<dt><strong>stats:</strong></dt>
<dd><p class="first last">&#8216;calculate_stats&#8217;, calculate_stats = 1; IN DEVELOPMENT</p>
</dd>
<dt><strong>noresiduals:</strong></dt>
<dd><p class="first last">write_residuals = 0;</p>
</dd>
<dt><strong>noplots:</strong></dt>
<dd><p class="first last">save_plots = 0;</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.rotate_to_pca">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">rotate_to_pca</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.rotate_to_pca" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate design matrix columns within all conditions to principal component projection.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;fmri_model.single_trial_estimates">
<code class="descclassname">&#64;fmri_model.</code><code class="descname">single_trial_estimates</code><span class="sig-paren">(</span><em>obj</em>, <em>fmri_data_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@fmri_model.single_trial_estimates" title="Permalink to this definition">¶</a></dt>
<dd><p>Write single trial estimates associated with an estimated fmri_model object.
must have estimated the model (robustfit(obj); see fmri_model.robustfit)
and saved hrf*.img images for each condition.</p>
<p>Also input an fmri_data object with time series data.</p>
<p>This function writes images, one 4-D image for each condition, with the
number of frames equalling the number of trials (onsets) for that
condition.</p>
<p>It does this by constructing a separate design matrix for each voxel,
which is based on the HRF estimates for that voxel for each condition.
Fits for all conditions are added to the same model, so that their
colinearity influences the single-trial parameter estimates.</p>
</dd></dl>

</div>
<div class="section" id="fmridisplay">
<h1>fmridisplay<a class="headerlink" href="#fmridisplay" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="module-&#64;image_vector">
<span id="image-vector"></span><h1>image_vector<a class="headerlink" href="#module-@image_vector" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;image_vector.apply_mask">
<code class="descclassname">&#64;image_vector.</code><code class="descname">apply_mask</code><span class="sig-paren">(</span><em>dat</em>, <em>mask</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.apply_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a mask image (image filename or fmri_mask_image object) to an image_vector object
stored in dat.</p>
<dl class="docutils">
<dt>This can be used to:</dt>
<dd><ul class="first last simple">
<li>Mask an image_vector or fmri_data object with a mask</li>
<li>Obtain &#8220;pattern expression&#8221; for a weight map (entered as the
mask, here) in a series of images stored in dat.</li>
</ul>
</dd>
</dl>
<p>The mask or weight map does not have to be in the same space as the dat;
it will be resampled to the space of the data in dat.</p>
<p>To extract pattern expression values for each ROI within a mask use extract_roi_averages()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>pattern_expression:</strong></dt>
<dd><p class="first last">calculate and return the cross-product of each
image in dat and the values in the mask.  This is useful if comparing
expression values that are comprised of different datasets or differing
number of voxels.</p>
</dd>
<dt><strong>correlation:</strong></dt>
<dd><p class="first last">calculate the pearson correlation coefficient of each
image in dat and the values in the mask.</p>
</dd>
<dt><strong>norm_mask:</strong></dt>
<dd><p class="first last">normalize the mask weights by L2 norm, for patt expression
only.</p>
</dd>
<dt><strong>ignore_missing:</strong></dt>
<dd><p class="first last">use with pattern expression only. Ignore weights on voxels
with zero values in test image. If this is not entered, the function will
check for these values and give a warning.</p>
</dd>
<dt><strong>invert:</strong></dt>
<dd><p class="first last">Invert the mask so that out-of-mask voxels are now in (using
the mask as an &#8216;exclude mask&#8217; rather than an include-mask. If pattern
expression is requested, the behavior is different, and it inverts the
sign of in-mask pattern weights.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[dat, mask] = apply_mask(dat, mask)
[dat, mask] = apply_mask(dat, mask image name)
[dat, mask] = apply_mask(dat, mask image vector object)
[pattern_exp_values] = apply_mask(dat, weight map image, &#39;pattern_expression&#39;, &#39;ignore_missing&#39;)
[pattern_exp_values] = apply_mask(dat, weight map image, &#39;pattern_expression&#39;, &#39;ignore_missing&#39;,&#39;correlation&#39;)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>extract_roi_averages, to get individual region averages / local pattern expression
apply_nps, which does whole-pattern and local regional expression</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.check_image_filenames">
<code class="descclassname">&#64;image_vector.</code><code class="descname">check_image_filenames</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.check_image_filenames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether images listed in obj.fullpath actually exist</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">check_image_filenames</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;noverbose&#39;</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Behavior:</th><td class="field-body"><ul class="first last simple">
<li>If there are no file names, do nothing.</li>
<li>If file names are entered and full path is not, attempt to find full
path.</li>
<li>If full path info is entered, check to see if files exist.
Return output in obj.files_exist, and print a warning if only some exist.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Image names should be stored in .fullpath
abbreviated image names may be stored in image_names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>fullpath should have full path to each volume in a string matrixm, with
trailing ,volume# for 4-D images as per SPM style expanded list.</p>
<p>image_names should have image name only for each volume</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.compare_space">
<code class="descclassname">&#64;image_vector.</code><code class="descname">compare_space</code><span class="sig-paren">(</span><em>obj</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.compare_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare spaces of two image_vector objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function isdiff = compare_space(obj, obj2)
</pre></div>
</div>
<p>Returns 0 if same, 1 if different spaces, 2 if no volInfo info for one or
more objects. 3 if same space, but different in-mask voxels in .dat or
volInfo.image_indx</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.extract_gray_white_csf">
<code class="descclassname">&#64;image_vector.</code><code class="descname">extract_gray_white_csf</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.extract_gray_white_csf" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts mean values (values) and top 5 component scores (components)
from each of gray, white, and CSF masks.
Images must be in standard MNI space for this to apply.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">values</span><span class="p">,</span> <span class="n">components</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_gray_white_csf</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">an image_vector (e.g., fmri_data) object</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.extract_roi_averages">
<code class="descclassname">&#64;image_vector.</code><code class="descname">extract_roi_averages</code><span class="sig-paren">(</span><em>obj</em>, <em>mask</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.extract_roi_averages" title="Permalink to this definition">¶</a></dt>
<dd><p>This image_vector method a extracts and averages data stored in an fmri_data object 
from a set of ROIs defined in a mask.
It is <em>slightly</em> different from the fmri_data method, as fmri_data has
more fields.</p>
<p>This version requires the mask_image to be in the same space as the obj.</p>
<p>Regions to average over can be either regions of contiguous voxels
bounded by voxels with values of 0 or NaN, which are considered non-data
values, or regions defined by unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region.)</p>
<p>Mask/Atlas image does NOT have to be in the same space as the images to
extract from.  It will be remapped/resliced.</p>
<p>Extracted data is returned in single data format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cl = extract_roi_averages(image_vector obj, mask, [average_over])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><ul class="first simple">
<li>char array of strings containing 4D image file names (data extracted from these)</li>
<li>mask_image to extract from.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>average_over:</strong></dt>
<dd><ul class="first last simple">
<li>Default: &#8216;contiguous_regions&#8217; to average over contiguous voxels
bounded by voxels of 0 or NaN (non-data values)</li>
<li>Alt. option = &#8216;unique_mask_values&#8217; to average over unique integer codes in the mask image
(i.e., for atlas images with unique codes for each defined region)</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">imgs_to_extract_from</span> <span class="o">=</span> <span class="n">filenames</span><span class="p">(</span><span class="s">&#39;w*.nii&#39;</span><span class="p">,</span><span class="s">&#39;char&#39;</span><span class="p">);</span>
<span class="n">mask_image</span> <span class="o">=</span> <span class="n">which</span><span class="p">(</span><span class="s">&#39;anat_lbpa_thal.img&#39;</span><span class="p">);</span>
<span class="p">[</span><span class="n">cl</span><span class="p">,</span> <span class="n">imgdat</span><span class="p">]</span> <span class="o">=</span> <span class="n">extract_image_data</span><span class="p">(</span><span class="n">imgs_to_extract_from</span><span class="p">,</span> <span class="n">mask_image</span><span class="p">);</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>For an non-object-oriented alternative, see extract_image_data.m</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.fastmontage">
<code class="descclassname">&#64;image_vector.</code><code class="descname">fastmontage</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.fastmontage" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates 3 separate montage views - ax, cor, sagg in a special figure window</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="n">myview</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;spacing&#39;</span><span class="p">,</span> <span class="n">slicespacing</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;vertical&#39;</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">);</span>
<span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;coronal&#39;</span><span class="p">);</span>
<span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;sagittal&#39;</span><span class="p">,</span> <span class="s">&#39;spacing&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;sagittal&#39;</span><span class="p">,</span> <span class="s">&#39;spacing&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;vertical&#39;</span><span class="p">);</span>
<span class="n">fastmontage</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="s">&#39;sagittal&#39;</span><span class="p">,</span> <span class="s">&#39;slices_per_row&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.flip">
<code class="descclassname">&#64;image_vector.</code><code class="descname">flip</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Flips an image_vector object left to right</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Input &#8216;mirror&#8217; to make a symmetrical image, averaging the left
and right hemispheres</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dat</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;mirror&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.get_wh_image">
<code class="descclassname">&#64;image_vector.</code><code class="descname">get_wh_image</code><span class="sig-paren">(</span><em>dat</em>, <em>wh</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.get_wh_image" title="Permalink to this definition">¶</a></dt>
<dd><p>For an image_vector with multiple images (cases, contrasts, etc.), select a subset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function obj_out = get_wh_image(obj1, wh)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj1:</strong></dt>
<dd><p class="first last">An image_vector object</p>
</dd>
<dt><strong>wh:</strong></dt>
<dd><p class="first last">An array indicating which images</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>my_image_vector = get_wh_image(dat, 3) %to get 3rd image
my_image_vector = get_wh_image(dat, [1 3]) %to get 1st and 3rd image
</pre></div>
</div>
<p>check that wh is in range</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.histogram">
<code class="descclassname">&#64;image_vector.</code><code class="descname">histogram</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.histogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="&#64;image_vector.history">
<code class="descclassname">&#64;image_vector.</code><code class="descname">history</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.history" title="Permalink to this definition">¶</a></dt>
<dd><p>Display history for image_vector object</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.horzcat">
<code class="descclassname">&#64;image_vector.</code><code class="descname">horzcat</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.horzcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the horzcat ([a b]) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function s = horzcat(varargin)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>c = [dat1 dat2];
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.ica">
<code class="descclassname">&#64;image_vector.</code><code class="descname">ica</code><span class="sig-paren">(</span><em>fmridat_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.ica" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Spatial ICA of an fmri_data object</dt>
<dd><ul class="first last simple">
<li>icadat = ica(fmridat_obj, [number of ICs to save])</li>
<li>icadat is also an fmri_data object, with .dat field voxels x components</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Notes:</th><td class="field-body"><ul class="first last simple">
<li>icasig = W * mixedsig</li>
<li>icasig = icadat.dat&#8217; = W * fmridat_obj.dat&#8217;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>A is scaled version of fmridat_obj.dat&#8217; * icadat.dat</p>
<p>A and W are stored in additional_info field of icadat</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_math">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_math</code><span class="sig-paren">(</span><em>obj1</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform simple mathematical and boolean operations on image objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj_out = image_math(obj1, [optional inputs, e.g., a 2nd object, keywords])
</pre></div>
</div>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj1:</strong></dt>
<dd><p class="first last">An image_vector object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>obj2:</strong></dt>
<dd><p class="first last">An additional image_vector object</p>
</dd>
<dt><strong>{&#8216;add&#8217;, &#8216;plus&#8217;}:</strong></dt>
<dd><dl class="first last docutils">
<dt>Keyword to perform image-wise addition of images in obj1</dt>
<dd><p class="first last">and obj2.  Assumes these are paired/matched objects.</p>
</dd>
</dl>
</dd>
<dt><strong>{&#8216;subtract&#8217;, &#8216;minus&#8217;}:</strong></dt>
<dd><dl class="first last docutils">
<dt>Keyword to perform image-wise subtraction of images</dt>
<dd><p class="first last">in obj1 and obj2</p>
</dd>
</dl>
</dd>
<dt><strong>{&#8216;cat&#8217;, &#8216;concatenate&#8217;}:</strong></dt>
<dd><dl class="first last docutils">
<dt>Concatenate obj1 and obj2 image-wise.  Requires same</dt>
<dd><p class="first last">number of voxels in both image sets.  Returns effects
codes of 1, -1 in obj_out.Y.</p>
</dd>
</dl>
</dd>
<dt><strong>{&#8216;power&#8217;}:</strong></dt>
<dd><dl class="first last docutils">
<dt>Keyword to raise data to power element-wise; obj.dat = obj.dat.^b;</dt>
<dd><p class="first last">Followed by exponent to apply (b)</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obj_out:</strong></dt>
<dd><p class="first last">The result - an image_vector object</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>DEFAULTS AND INPUTS
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_similarity_plot">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_similarity_plot</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_similarity_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-biserial correlations between images in fmri_data obj and set of
&#8216;spatial basis function&#8217; images (e.g., &#8216;signatures&#8217; or pre-defined maps)</p>
<p>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stats</span> <span class="o">=</span> <span class="n">image_similarity_plot</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;average&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>This is a method for an image_vector object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">An image object with one or more images loaded</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>average:</strong></dt>
<dd><p class="first last">Calculate average over images in obj with standard errors
Useful if obj contains one image per subject and you want
to test similarity with maps statistically.
Default behavior is to plot each individual image.</p>
</dd>
<dt><strong>bucknerlab</strong></dt>
<dd><p class="first last">Use 7 network parcellation from Yeo et al. as basis for
comparisons</p>
</dd>
<dt><strong>kragelemotion</strong></dt>
<dd><p class="first">Use 7 emotion-predictive models from Kragel &amp; LaBar 2015 for
basis of comparisons</p>
<p class="last"><strong>compareGroups</strong>
Perform multiple one-way ANOVAs with group as a factor (one for
each spatial basis); requires group as subsequent input</p>
</dd>
<dt><strong>group</strong></dt>
<dd><p class="first last">Indicates group membership for each image</p>
</dd>
<dt><strong>noplot</strong></dt>
<dd><p class="first last">Omits plot (print stats only)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>stats:</strong></dt>
<dd><dl class="first last docutils">
<dt>Structure including:</dt>
<dd><ul class="first last simple">
<li>.r, Correlations in [7 networks x images in obj] matrix</li>
<li>.t, T-test (if &#8216;average&#8217; is specified)</li>
<li>.line_handles Handles to polar plot lines so you can
customize</li>
<li>.fill_handles Handles to polar plot fills so you can
customize</li>
<li>.table_spatial, ANOVA table with subject as row factor and
spatial basis as column factor (one way repeated measures
ANOVA, requires &#8216;average&#8217; to be specified)</li>
<li>.multcomp_spatial, multiple comparisons of means across
different spatial bases, critical value determined
by Tukey-Kramer method (see multcompare)</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>table_group</strong></dt>
<dd><p class="first last">multiple one-way ANOVA tables (one for each
spatial basis) with group as column factor (requires
&#8216;average&#8217; to be specified)</p>
</dd>
<dt><strong>multcomp_group</strong></dt>
<dd><p class="first last">mutiple comparisons of means across groups, one output
cell for each spatial basis, critical value determined
by Tukey-Kramer method (see multcompare)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% corrdat is an fmri_data object with 18 images from searchlight
% correlation in it.  Then:
stats = image_similarity_plot_bucknermaps(corrdat, &#39;average&#39;);

% t_diff is a thresholded statistic_image object
stats = image_similarity_plot_bucknermaps(t_diff);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>tor_polar_plot</p>
<p>List dates and changes here, and author of changes
11/30/2015 (Phil Kragel)</p>
<blockquote>
<div><ul class="simple">
<li>added anova (rm) comparing means across spatial bases</li>
<li>added anova (1-way) comparing means across groups for each spatial
basis (e.g., for each buckner network)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>12/15/2015 (Phil Kragel)</dt>
<dd><ul class="first last simple">
<li>added option to omit plotting</li>
</ul>
</dd>
</dl>
<p>DEFAULTS AND INPUTS
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.image_similarity_plot_bucknermaps">
<code class="descclassname">&#64;image_vector.</code><code class="descname">image_similarity_plot_bucknermaps</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.image_similarity_plot_bucknermaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-biserial correlations between images in fmri_data obj and Bucker
Lab 7-network maps, with polar plot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stats</span> <span class="o">=</span> <span class="n">image_similarity_plot_bucknermaps</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;average&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>This is a method for an image_vector object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">An image object with one or more images loaded</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>average:</strong></dt>
<dd><p class="first last">Calculate average over images in obj with standard errors
Useful if obj contains one image per subject and you want
to test similarity with maps statistically.
Default behavior is to plot each individual image.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>stats:</strong></dt>
<dd><dl class="first last docutils">
<dt>Structure including:</dt>
<dd><ul class="first last simple">
<li>.r, Correlations in [7 networks x images in obj] matrix</li>
<li>.t, T-test (if &#8216;average&#8217; is specified)</li>
<li>.line_handles Handles to polar plot lines so you can
customize</li>
<li>.fill_handles Handles to polar plot fills so you can
customize</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% corrdat is an fmri_data object with 18 images from searchlight
% correlation in it.  Then:
stats = image_similarity_plot_bucknermaps(corrdat, &#39;average&#39;);

% t_diff is a thresholded statistic_image object
stats = image_similarity_plot_bucknermaps(t_diff);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>tor_polar_plot</p>
<p>DEFAULTS AND INPUTS
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.interpolate">
<code class="descclassname">&#64;image_vector.</code><code class="descname">interpolate</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate over missing values in image_vector object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dat</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body">image_vector object (dat; e.g., an fmri_data object)</td>
</tr>
</tbody>
</table>
<p>Use when there are some missing values in the mask image
Performs 3-D linear interpolation to fill in all values in the original
mask.</p>
<p>e.g., For a standard brain image space that is 91 x 109 x 91, you may
have 300,000 in-mask values. Only 150,000 of these may be defined in the
image, however, and the rest are missing (0 or NaN).
This function will return a dat image with non-missing values for all
300,000 voxels (the &#8220;in-mask&#8221; space). 
It will not return values for all voxels in the 91 x 109 x 91 space,
however.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>This function does not upsample the data now, but could be extended
to do so fairly easily.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.mean">
<code class="descclassname">&#64;image_vector.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image_vector object with mean values for each voxel (cols)
across images (rows) of an fmri_data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function m = mean(obj, [optional args])
</pre></div>
</div>
<p>m is an image_vector object whose data contains the mean values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li>&#8216;write&#8217;, followed by file name</li>
<li>&#8216;path&#8217;, followed by location for file (default = current directory)</li>
<li>&#8216;orthviews&#8217; -&gt; show orthviews for this image, same as orthviews(m)</li>
<li>&#8216;histogram&#8217; -&gt; show histogram for this image, same as histogram(m)</li>
<li>&#8216;plot&#8217; -&gt; do both</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% If sdat is an fmri_data object with multiple images,
m = mean(sdat, &#39;plot&#39;, &#39;write&#39;, anatmeanname, &#39;path&#39;, maskdir);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.minus">
<code class="descclassname">&#64;image_vector.</code><code class="descname">minus</code><span class="sig-paren">(</span><em>obj1</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the minus (-) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.montage">
<code class="descclassname">&#64;image_vector.</code><code class="descname">montage</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a montage of an image_vector (or statistic_image or fmri_data) object</p>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre>[fig_handle or o2 fmridisp object] = montage(image_obj, [optional arguments])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>fmridisplay:</strong></dt>
<dd><p class="first last">for fmridisplay object style montage [default]</p>
</dd>
<dt><strong>scnmontage:</strong></dt>
<dd><p class="first last">for circa 2008-style SCN lab montage for each image vector</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">o2</span> <span class="o">=</span> <span class="n">montage</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.orthviews">
<code class="descclassname">&#64;image_vector.</code><code class="descname">orthviews</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.orthviews" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthviews display (SPM) for CANlab image_vector (or fmri_data, statistic_image) object</p>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">orthviews</span><span class="p">(</span><span class="n">image_obj</span><span class="p">,</span> <span class="n">varargin</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>posneg:</strong></dt>
<dd><p class="first last">input generates orthviews using solid colors.</p>
</dd>
<dt><strong>largest_region:</strong></dt>
<dd><p class="first last">to center the orthviews on the largest region in the image</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.plot_current_orthviews_coord">
<code class="descclassname">&#64;image_vector.</code><code class="descname">plot_current_orthviews_coord</code><span class="sig-paren">(</span><em>dat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.plot_current_orthviews_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves and plots the image data series at the current crosshairs in spm_orthviews</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.plus">
<code class="descclassname">&#64;image_vector.</code><code class="descname">plus</code><span class="sig-paren">(</span><em>obj1</em>, <em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the plus (+) operator on image_vector objects across voxels.
Requires that each object has an equal number of columns and voxels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">dat1</span> <span class="o">+</span> <span class="n">dat2</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.power">
<code class="descclassname">&#64;image_vector.</code><code class="descname">power</code><span class="sig-paren">(</span><em>obj</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.power" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the power (^) operator on image_vector objects across voxels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">dat1</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>Programmer Notes:
Created 3/14/14 by Luke Chang
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.preprocess">
<code class="descclassname">&#64;image_vector.</code><code class="descname">preprocess</code><span class="sig-paren">(</span><em>obj</em>, <em>meth</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocesses data in an fmri_data object</p>
<p>Data is observations (i.e., voxels, subjects) x images, so operating on the columns operates on
images, and operating on the rows operates on voxels (or variables more
generally) across images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><p class="first"><strong>meth:</strong> Options</p>
<dl class="docutils">
<dt><strong>resid:</strong></dt>
<dd><p class="first last">Residualize voxels with respect to covariates
Uses obj.covariates, obj.dat.
Adds intercept automatically. You can tell it to add the mean response per voxel back in:
obj = preprocess(obj, &#8216;resid&#8217;, [add mean back in flag])</p>
</dd>
<dt><strong>hpfilter:</strong></dt>
<dd><p class="first last">High-pass filter and remove run intercepts and first two
images per run. Uses obj.dat, obj.images_per_session
obj = preprocess(obj, &#8216;hpfilter&#8217;, HPlen in s, TR)</p>
</dd>
<dt><strong>windsorize:</strong></dt>
<dd><p class="first last">Windsorize entire data matrix to 3 STD</p>
</dd>
<dt><strong>windsorizevoxels:</strong></dt>
<dd><p class="first last">Windsorize each time series in data matrix to 3 STD</p>
</dd>
<dt><strong>session_outliers:</strong></dt>
<dd><p class="first last">Identify session-wise (run-wise) outliers with significant
based on mahalanobis distance with FDR-corrected P-values in chi-square test.
Impute session grand mean outliers.</p>
</dd>
<dt><strong>outliers:</strong></dt>
<dd><p class="first last">Identify outlier time points for each session based on
mahalanobis distance (see above) across global mean for slices and
spatial STD for slices, as in scn_session_spike_id.
Outliers at 3 SD based on timeseries added to obj.covariates.</p>
</dd>
<dt><strong>outliers_rmssd:</strong></dt>
<dd><p class="first last">Identify outlier time points for each session based on
root-mean-square successive differences between images (across voxels.)
this is the std (across voxels) of the successive diffs across images.
Outliers at 3.5 SD based on timeseries added to obj.covariates.</p>
</dd>
<dt><strong>smooth:</strong></dt>
<dd><dl class="first docutils">
<dt>Smoothed images with Gaussian filter</dt>
<dd><ul class="first last simple">
<li>obj = preprocess(obj, &#8216;smooth&#8217;, FWHM in mm)</li>
</ul>
</dd>
</dl>
<p class="last"><em>NOTE</em> SMOOTHING KERNEL MAY BE IN VOX, AS VOL INFO IS NOT PASSED IN</p>
</dd>
<dt><strong>interp_images:</strong></dt>
<dd><p class="first">Interpolate all voxels in a series of images specified
by logical vector whout.</p>
<blockquote class="last">
<div><ul class="simple">
<li>obj = preprocess(obj, &#8216;interp_images&#8217;, whout);</li>
</ul>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% two complementary ways to get and plot outliers:
dat = preprocess(dat, &#39;outliers&#39;, &#39;plot&#39;);
subplot(5, 1, 5); % go to new panel...
dat = preprocess(dat, &#39;outliers_rmssd&#39;, &#39;plot&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.read_from_file">
<code class="descclassname">&#64;image_vector.</code><code class="descname">read_from_file</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.read_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads data from image filenames into obj.dat</p>
<p>Try obj = check_image_filenames(obj) first.</p>
<p>This is automatically called if you create a new image_vector object with
names but do not directly enter data. e.g., the commands below will load data:</p>
<blockquote>
<div><ul class="simple">
<li>name = &#8216;salientmap.nii&#8217;;</li>
<li>img = image_vector(&#8216;image_names&#8217;, name);</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.rebuild_volinfo_from_dat">
<code class="descclassname">&#64;image_vector.</code><code class="descname">rebuild_volinfo_from_dat</code><span class="sig-paren">(</span><em>dat</em>, <em>newdat</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.rebuild_volinfo_from_dat" title="Permalink to this definition">¶</a></dt>
<dd><p>Will rebuild volInfo (the image space, or sometimes &#8220;mask&#8221;) from a vectorized image. 
In other words, will rebuild dat.volInfo from newdat.</p>
<p>Also resets all voxels to be significant, if a statistic image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Input:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">an image_vector</p>
</dd>
<dt><strong>newdat:</strong></dt>
<dd><p class="first last">a vector that MUST be size of ENTIRE image (dat.volInfo.nvox)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Output:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">dat.dat contains the non-zero values of newdat, and dat.volInfo is
correctly defining the image space</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.reconstruct_image">
<code class="descclassname">&#64;image_vector.</code><code class="descname">reconstruct_image</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.reconstruct_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct a 3-D or 4-D image from image_vector object obj</p>
<p>voldata is and X x Y x Z x Images matrix
vectorized_voldata is the same, with all voxels vectorized</p>
<p>This output has one element for every voxel in THE ENTIRE IMAGE, and so
can be very memory-intensive.  But it&#8217;s useful for lining up voxels
across images with different masks/in-mask voxels.</p>
<p>This function returns output in memory;
see image_vector.write for writing .img files to disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>voldata:</strong></dt>
<dd><p class="first last">3-D recon volume</p>
</dd>
<dt><strong>vectorized_voldata:</strong></dt>
<dd><p class="first last">volume in column vetor, iimg_xxx function format</p>
</dd>
<dt><strong>xyz_coord_struct:</strong></dt>
<dd><dl class="first last docutils">
<dt>has fields with coordinate information in mm (world) space</dt>
<dd><ul class="first last simple">
<li>x, y, z : vectors of coordinates in mm for each of the 3
dimensions of the image</li>
<li>X, Y, Z : output matrices from meshgrid with mm coordinates,
for volume visualization.
These can be passed to surf or isocaps functions for volume
visualization in world space (mm).</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.remove_empty">
<code class="descclassname">&#64;image_vector.</code><code class="descname">remove_empty</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.remove_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>remove vox: logical vector of custom voxels to remove, VOX x 1</p>
<p>remove im: logical vector of custom images to remove, 1 x IMAGES</p>
<p>indices of removed data will be stored in removed_voxels and
removed_images fields, to preserve ability to later reconstruct into 3D images</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>dat = remove_empty(dat, [logical vector of custom voxels to remove], [logical vector of imgs to remove])
</pre></div>
</div>
<p>Indicator vectors stored in:
removed_images
removed_voxels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">replace_empty</td>
</tr>
</tbody>
</table>
<p>force logical</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.reparse_contiguous">
<code class="descclassname">&#64;image_vector.</code><code class="descname">reparse_contiguous</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.reparse_contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-construct list of contiguous voxels in an image based on in-image
voxel coordinates.  Coordinates are taken from obj.volInfo.xyzlist.</p>
<p>Results are saved in obj.volInfo.cluster.</p>
<p>xyzlist can be generated from iimg_read_img, and is done automatically by
object-oriented fMRI image classes (fmri_image, image_vector,
statistic_image)</p>
<p>If &#8216;nonempty&#8217; is entered as an optional argument, will use only voxels
that are non-zero, non-nan in all columns of obj.dat.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">reparse_contiguous</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;nonempty&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>.cluster and .xyzlist should both always be length v in-mask voxels
if &#8216;nonempty&#8217; is entered, then .dat should be length v in-mask voxels too</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.replace_empty">
<code class="descclassname">&#64;image_vector.</code><code class="descname">replace_empty</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.replace_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace empty/missing values in an image data object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = replace_empty(obj, [optional keywords])
</pre></div>
</div>
<p>Replace missing values in obj.dat stored in obj.removed_voxels and
obj.removed_images with zeros.  This returns obj.dat in a format that can
be reconstructed into a 3-D or 4-D image matrix for brain visualization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional keywords:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>&#8216;voxels&#8217; or &#8216;images&#8217;:</strong></dt>
<dd><p class="first last">replace only missing voxels/images</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">remove_empty, zeroinsert, nanremove, naninsert</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.resample_space">
<code class="descclassname">&#64;image_vector.</code><code class="descname">resample_space</code><span class="sig-paren">(</span><em>obj</em>, <em>sampleto</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.resample_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the images in an fmri_data object (obj) to the space of another
image (sampleto; e.g., a mask image). Works for all image_vector objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = resample_space(obj, sampleto, [sampling method])
</pre></div>
</div>
<dl class="docutils">
<dt>Sampleto may be one of these:</dt>
<dd><ol class="first last arabic simple">
<li>a volInfo structure (the image does not have to exist on the path)</li>
<li>an image_vector, fmri_data, fmri_mask_image object</li>
<li>a string with the name of an image</li>
</ol>
</dd>
</dl>
<p>Can enter resampling method as optional input. Takes any input to
interp3:</p>
<blockquote>
<div><p>&#8216;nearest&#8217; - nearest neighbor interpolation
&#8216;linear&#8217;  - linear interpolation (default)
&#8216;spline&#8217;  - spline interpolation
&#8216;cubic&#8217;   - cubic interpolation as long as the data is uniformly</p>
<blockquote>
<div>spaced, otherwise the same as &#8216;spline&#8217;</div></blockquote>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>label_mask = fmri_data(which(&#39;atlas_labels_combined.img&#39;));
label_mask = resample_space(label_mask, ivec, &#39;nearest&#39;) % resamples and masks label image
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.resample_time">
<code class="descclassname">&#64;image_vector.</code><code class="descname">resample_time</code><span class="sig-paren">(</span><em>obj</em>, <em>source_TR</em>, <em>target_TR</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.resample_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the time-series images (source_time_interval) in an fmri_data object (obj) 
to the different time series (target_time_interval). Works for all image_vector objects.</p>
<blockquote>
<div><ul class="simple">
<li>obj = resample_time(obj, source_time_interval, target_time_interval, varargin)</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>meth (Interpolation methods):</strong></dt>
<dd><dl class="first last docutils">
<dt>You can enter resampling method as optional input. Takes any input to</dt>
<dd><ul class="first last">
<li><p class="first">&#8216;nearest&#8217; - nearest neighbor interpolation</p>
</li>
<li><p class="first">&#8216;linear&#8217;  - linear interpolation (default)</p>
</li>
<li><p class="first">&#8216;spline&#8217;  - spline interpolation</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;cubic&#8217;   - cubic interpolation as long as the data is uniformly</dt>
<dd><p class="first last">spaced, otherwise the same as &#8216;spline&#8217;</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>slice:</strong></dt>
<dd><p class="first last">A fraction of the slice timing correction.
The default is 0.5, meaning if your TR is 2s, the time point of your TR image
will be considered as the middle point of the TR bins. You can use this option
to use different time points. If you are upsampling your data (i.e.,
your target TR is shorter than your source TR), you need to discard the
first column of your data. This function will return the first time point data as NaN.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>dat = fmri_data(&#39;/Volumes/RAID1/labdata/current/BMRK3/Imaging/spatiotemp_biomarker/STmarker1.img&#39;);
dat = resample_time(dat, 2, 1.3) 

% with options:
dat = resample_time(dat, 2, 1.3, &#39;meth&#39;, &#39;linear&#39;, &#39;slice&#39;, .3)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.sagg_slice_movie">
<code class="descclassname">&#64;image_vector.</code><code class="descname">sagg_slice_movie</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.sagg_slice_movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Movie of successive differences (sagittal slice)
Enter an image_vector or fmri_data object (usually with time series)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sagg_slice_movie</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">[</span><span class="n">full_path_of_movie_output_file</span><span class="p">,</span><span class="n">image_skip_interval</span><span class="p">])</span>
</pre></div>
</div>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>Optional Inputs:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>movie_output_file:</strong></dt>
<dd><dl class="first last docutils">
<dt>a char array detailing the full path to save the</dt>
<dd>movie file</dd>
</dl>
</dd>
<dt><strong>image_skip_interval:</strong></dt>
<dd><blockquote class="first">
<div>An integer value describing the interval 
between images in each subsequent frame of the movie</div></blockquote>
<p class="last">(default = 1)</p>
</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre> sagg_slice_movie(fmri_dat, ...
            &#39;/Volumes/engram/labdata/fmri_data/Study1/Subj1/qc_images&#39;, 5)

This would save an movie based on the images in fmri_dat to the
above directory, with an interval of 5 images between each
frame (so, the movie would show image 1, 6, 11, 16, etc)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.searchlight">
<code class="descclassname">&#64;image_vector.</code><code class="descname">searchlight</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.searchlight" title="Permalink to this definition">¶</a></dt>
<dd><p>Run searchlight multivariate prediction/classification on an image_vector
or fmri_data object OR two objects, for cross-prediction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[list outputs here] = function_name(list inputs here, [optional inputs])
[results_obj, stats, indx] = searchlight(dat, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body"><ul class="first last simple">
<li>Runs searchlight with standard, pre-defined algorithms</li>
<li>Custom-entry definition of holdout sets</li>
<li>Can re-use searchlight spheres after initial definition</li>
<li>Custom-entry definition of any spheres/regions of interest</li>
<li>Uses Matlab&#8217;s parallel processing toolbox (parfor)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Type help image_vector.searchlight to display this help information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">image_vector or fmri_data object with data</p>
</dd>
<dt><strong>dat.Y:</strong></dt>
<dd><p class="first last">required: true outcomes for each observation (image) in dat</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>:Optional Inputs:* Keyword followed by input variable:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>r:</strong></dt>
<dd>searchlight radius, voxels</dd>
<dt><strong>dat2:</strong></dt>
<dd>second dataset, for cross-prediction</dd>
<dt><strong>indx:</strong></dt>
<dd>sparse logical matrix. each COLUMN is index of inclusion sets for each region/sphere in searchlight
This takes a long time to calculate, but can be saved and
re-used for a given mask</dd>
<dt><strong>holdout_set:</strong></dt>
<dd>Followed by integer vector of which observations belong to which
holdout set, for cross-validation. This is passed into fmri_data.predict.m.  Default is
empty.</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>results_obj:</strong></dt>
<dd><p class="first last">fmri_data object with results maps</p>
</dd>
<dt><strong>stats:</strong></dt>
<dd><p class="first last">selected statistics for each sphere in searchlight</p>
</dd>
<dt><strong>indx:</strong></dt>
<dd><p class="first last">sparse logical matrix. each COLUMN is index of inclusion sets for each region/sphere in searchlight
* this can be re-used for all data with the same mask/structure. *</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Define a sensible gray-matter mask:
dat = fmri_data(which(&#39;scalped_avg152T1_graymatter.img&#39;));
dat = threshold(dat, [.8 Inf], &#39;raw-between&#39;);
dat = trim_mask(dat);

% Create fake data and holdout indicator index vector
dat.dat = randn(dat.volInfo.n_inmask, 30);
dat.Y = dat.dat(111111, :)&#39; + .3 * randn(30, 1);
holdout_set = ones(6, 1); for i = 2:5, holdout_set = [holdout_set; i*ones(6, 1)]; end

% Run, and run again with existing indx
pool = parpool(12);  % initialize parallel processing (12 cores)
[results_obj, stats, indx] = searchlight(dat, &#39;holdout_set&#39;, holdout_set);
results_obj = searchlight(dat, &#39;holdout_set&#39;, holdout_set, &#39;indx&#39;, indx);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>region.m, fmri_data.predict.m</p>
<p>DEFAULTS AND INPUTS
..</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.slices">
<code class="descclassname">&#64;image_vector.</code><code class="descname">slices</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a montage of single-slice results for every image in an
image_vector object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">o</span> <span class="o">=</span> <span class="n">slices</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;orientation&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">orientation</span><span class="p">],</span> <span class="s">&#39;slice&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">slice_mm</span><span class="p">],</span> <span class="s">&#39;nimages&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">nimgs</span><span class="p">])</span>
</pre></div>
</div>
<p>obj is an image_vector, fmri_data, or statistic_image object with
multiple images (only the first 64 will display), which are stored as
columns in its .dat field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>orientation:</strong></dt>
<dd><p class="first last">can be followed by &#8216;sagittal&#8217;, &#8216;axial&#8217;, or &#8216;coronal&#8217;</p>
</dd>
<dt><strong>slice_mm:</strong></dt>
<dd><p class="first last">is followed by the mm coord of the slice to display; default = 0</p>
</dd>
<dt><strong>nimgs:</strong></dt>
<dd><p class="first last">can be followed by the number of images to display, 1:nimgs</p>
</dd>
<dt><strong>names:</strong></dt>
<dd><p class="first last">is followed by a cell array of names for the images.</p>
</dd>
<dt><strong>color:</strong></dt>
<dd><p class="first last">is followed by color vector or string specification. default is
color-mapped with split colors (hot/cool) for pos and neg effects.</p>
</dd>
<dt><strong>outline:</strong></dt>
<dd><p class="first last">is followed by a color vector for outline around blobs.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>The output, o, is an fmridisplay object.</p>
<p>This function uses fmridisplay objects, and may be memory-intensive for
older computers.</p>
<p><em>Common Errors:</em></p>
<p>This function uses the volInfo.cluster field. If you create a mask in an
ad hoc way, this field may not be updated.  use this to fix:</p>
<blockquote>
<div><ul class="simple">
<li>mask = reparse_contiguous(mask);</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>slices(dat);
slices(dat, &#39;orientation&#39;, &#39;axial&#39;);
slices(dat, &#39;slice&#39;, -5);                 % display sagg at x = -5
o = slices(dat, &#39;names&#39;, terms); % use &#39;terms&#39; var as names

o2 = slices(all_chi2_images, &#39;orientation&#39;, &#39;sagittal&#39;, &#39;slice&#39;, 0);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.surface">
<code class="descclassname">&#64;image_vector.</code><code class="descname">surface</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.surface" title="Permalink to this definition">¶</a></dt>
<dd><p>[all_surf_handles, pcl, ncl] = surface(obj)</p>
<dl class="docutils">
<dt><em>Usage:</em></dt>
<dd><ul class="first last simple">
<li>[all_surf_handles, pcl, ncl] = surface(r, [&#8216;cutaways&#8217;, any optional inputs to surface_cutaway])</li>
</ul>
</dd>
</dl>
<p>This function uses region.surface to create surface figures.
See help region.surface for options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Create an initial surface plot from an fmri_data object:
han = surface(regionmasks{2});  

% Now add a second region in green:
cluster_surf(region(regionmasks{2}), {[0 1 0]}, han, 5);

% Use optional arguments taken by surface_cutaway:
poscm = colormap_tor([1 .3 0], [1 1 0]); % orange to yellow
[all_surf_handles, pcl, ncl] = surface(t, &#39;cutaway&#39;, &#39;ycut_mm&#39;, -30, &#39;pos_colormap&#39;, poscm, &#39;existingfig&#39;);
[all_surf_handles2, pcl, ncl] = surface(t, &#39;foursurfaces&#39;, &#39;pos_colormap&#39;, poscm, &#39;neg_colormap&#39;, negcm);
[all_surf_handles2, pcl, ncl] = surface(t, &#39;foursurfaces&#39;, &#39;existingfig&#39;, &#39;color_upperboundpercentile&#39;, 95, &#39;color_lowerboundpercentile&#39;, 5, &#39;neg_colormap&#39;, colormap_tor([0 0 1], [.3 0 .5]));

% Use mediation_brain_surface_figs and re-make colors
all_surf_handles = mediation_brain_surface_figs([]);
surface(t2, &#39;cutaway&#39;, &#39;surface_handles&#39;, all_surf_handles, &#39;color_upperboundpercentile&#39;, 95, &#39;color_lowerboundpercentile&#39;, 5, &#39;neg_colormap&#39;, colormap_tor([0 0 1], [.2 0 .5]));
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.threshold">
<code class="descclassname">&#64;image_vector.</code><code class="descname">threshold</code><span class="sig-paren">(</span><em>obj</em>, <em>input_threshold</em>, <em>thresh_type</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold image_vector (or fmri_data or fmri_obj_image) object based on
raw threshold values. For statistical thresholding, convert to a
statistic_image object and see the threshold method for that object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>obj = threshold(obj, input_threshold, thresh_type, [optional arguments])
</pre></div>
</div>
<p>This is a method for an image_vector object</p>
<p>Thresholding is not reversible. For statistic_image objects it is.</p>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">image_vector object</p>
</dd>
<dt><strong>input_threshold:</strong></dt>
<dd><p class="first last">Vector of 2 values defining data value bounds at which
to threshold, e.g., [0 Inf] or [-3 3]</p>
</dd>
<dt><strong>thresh_type:</strong></dt>
<dd><p class="first last">String: &#8216;raw-between&#8217; or &#8216;raw-outside&#8217;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Argument or argument followed by value:</p>
<dl class="docutils">
<dt><strong>k:</strong></dt>
<dd><p class="first last">Followed by extent threshold cluster size, default = 1</p>
</dd>
<dt><strong>trim_mask:</strong></dt>
<dd><p class="first last">Reduce the mask in obj.voInfo based on thresholding</p>
</dd>
<dt><strong>noverbose:</strong></dt>
<dd><p class="first last">Suppress verbose output</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj:</strong></dt>
<dd><p class="first last">thresholded image_vector object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Retain positive values, cluster extent &gt; 100 voxels
obj = threshold(obj, [0 Inf], &#39;raw-between&#39;, &#39;k&#39;, 100)

% Retain voxels with absolute value &gt; 3
obj = threshold(obj, [-3 3], &#39;raw-outside&#39;)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>statistic_image.threshold, statistic_image.multi_threshold</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.trim_mask">
<code class="descclassname">&#64;image_vector.</code><code class="descname">trim_mask</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.trim_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude empty voxels from mask information in obj.volInfo structure, and re-make obj.volInfo</p>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.union">
<code class="descclassname">&#64;image_vector.</code><code class="descname">union</code><span class="sig-paren">(</span><em>dat1</em>, <em>dat2</em>, <em>outputname</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Union and intersection masks for two image_vector objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[dat_union, dat_intersection] = union(dat1, dat2, outputname)

 dat = union(dat1, dat2, outputname)
 outputname = character array name for union image
               INCLUDE .img at the end.
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;image_vector.write">
<code class="descclassname">&#64;image_vector.</code><code class="descname">write</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@image_vector.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an image_vector object to an Analyze image.
Option to write thresholded image, for statistic_image objects.</p>
<p>obj.dat should contain data, with one COLUMN for each 3-D frame in the
4-D image to be written.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>write(obj)  -&gt; writes to the image(s) specified in obj.fullpath
write(obj, &#39;thresh&#39;) -&gt; for statistic_image objects, writes thresholded
write(obj, &#39;fname&#39;, &#39;~/Documents/test.nii&#39;)  -&gt; writes the image(s) to specific path
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>mni:</strong></dt>
<dd><p class="first last">resample image to standard MNI FOV (91x109x91)
uses mri_data.resample_space</p>
</dd>
<dt><strong>keepdt:</strong></dt>
<dd><p class="first last">output image will be keep original data type (default = float32)</p>
</dd>
<dt><strong>fname:</strong></dt>
<dd><p class="first last">writes out image to specific file name.  &#8216;fname&#8217; must be
followed by image name with path</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% If m is an image_vector object m.X(m.X &lt; .12) = 0; % apply an 
% arbitrary but reasonable custom threshold
orthviews(m);

% write the thresholded image to disk:
anatmeanname = &#39;mean_gray_matter_mask.img&#39;;
m.filename = anatmeanname;
m.fullpath = fullfile(maskdir, anatmeanname);
write(m)
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-&#64;region">
<span id="region"></span><h1>region<a class="headerlink" href="#module-@region" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;region.check_extracted_data">
<code class="descclassname">&#64;region.</code><code class="descname">check_extracted_data</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.check_extracted_data" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Checks the data, just in case of space/programming issues, </dt>
<dd>by re-extracting the region average data from 5 random regions 
using spm_get_data.m, and compares it to the already-saved values</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><blockquote class="first">
<div><dl class="docutils">
<dt><strong>cl:</strong></dt>
<dd><p class="first last">must be a valid region object (see region.m)
and cl(1).source_images must still be on the path.</p>
</dd>
</dl>
</div></blockquote>
<p class="last">You should not need to run this regularly &#8211; but you should if you
suspect things have gone awry.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;region.extract_data">
<code class="descclassname">&#64;region.</code><code class="descname">extract_data</code><span class="sig-paren">(</span><em>r</em>, <em>data_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.extract_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract data from image_vector object (data_obj) for voxels specified
by a region object (r). Returns extracted data and averages.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">region_obj</span> <span class="o">=</span> <span class="n">extract_data</span><span class="p">(</span><span class="n">region_obj</span><span class="p">,</span> <span class="n">data_obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Type methods(region) for a list of special commands for region object
Type help object_name.method_name for help on specific methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Features:</th><td class="field-body">data_obj does not have to be in the same space, uses mm coordinates</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r:</strong></dt>
<dd><p class="first last">a region object</p>
</dd>
<dt><strong>data_obj:</strong></dt>
<dd><p class="first last">an image_vector or fmri_data object to extract data from
does not have to be in the same space, uses mm coordinates</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r:</strong></dt>
<dd><p class="first last">a region object, with data attached</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;region.merge">
<code class="descclassname">&#64;region.</code><code class="descname">merge</code><span class="sig-paren">(</span><em>cl</em>, <em>wh_merge</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge two or more regions together in a region object.
Combines fields from all clusters in the named series with the first one
in the series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>wh_merge = [3 4];
cl = merge(cl, wh_merge)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.posneg_separate">
<code class="descclassname">&#64;region.</code><code class="descname">posneg_separate</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.posneg_separate" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a region object (cl) into clusters with positive and negative
peak values, based on max (peak) value in .val or .Z field (default =
val)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">pcl</span><span class="p">,</span> <span class="n">ncl</span><span class="p">]</span> <span class="o">=</span> <span class="n">posneg_separate</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Z&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Returns pcl and ncl, region structures with positive- and negative-valued
peaks, respectively, copied from the original cl input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Optional Input:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Z:</strong></dt>
<dd><p class="first last">To use .Z field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">You may have to use reparse_continguous to get this to work right.</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">reparse_continguous</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="p">[</span><span class="n">pcl</span><span class="p">,</span> <span class="n">ncl</span><span class="p">]</span> <span class="o">=</span> <span class="n">posneg_separate</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2imagevec">
<code class="descclassname">&#64;region.</code><code class="descname">region2imagevec</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2imagevec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a region object to an image_vector object, replacing the voxels
and reconstructing as much info as possible.</p>
<p>The .dat field of the new &#8220;ivecobj&#8221; is made from the cl.all_data field.
if this is empty, uses cl.val field, then cl.Z as a backup.
Mask information is available in ivecobj.volInfo.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ivecobj</span> <span class="o">=</span> <span class="n">region2imagevec</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2imagevec2tmp">
<code class="descclassname">&#64;region.</code><code class="descname">region2imagevec2tmp</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2imagevec2tmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a region object to an image_vector object, replacing the voxels
and reconstructing as much info as possible.</p>
<p>The .dat field of the new &#8220;ivecobj&#8221; is made from the cl.all_data field.
if this is empty, uses cl.val field, then cl.Z as a backup.
Mask information is available in ivecobj.volInfo.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ivecobj</span> <span class="o">=</span> <span class="n">region2imagevec</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.region2struct">
<code class="descclassname">&#64;region.</code><code class="descname">region2struct</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.region2struct" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a region object to a simple structure, primarily for
compatibility with other, older CANlab tools.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">cluster2region, for the reverse transformation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;region.reparse_continguous">
<code class="descclassname">&#64;region.</code><code class="descname">reparse_continguous</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.reparse_continguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-define regions in region object based on contiguous blobs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">clout</span> <span class="o">=</span> <span class="n">reparse_continguous</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.subdivide_by_atlas">
<code class="descclassname">&#64;region.</code><code class="descname">subdivide_by_atlas</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.subdivide_by_atlas" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>r = subdivide_by_atlas(r, [atlas name])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>r:</strong></dt>
<dd><p class="first last">a region object, defined using region(mask)</p>
</dd>
<dt><strong>atlas name:</strong></dt>
<dd><p class="first last">Optional mask image with integer codes defining in-mask
regions.  Default is &#8216;atlas_labels_combined.img&#8217;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Output:</th><td class="field-body"><p class="first">A region object with separate clusters for each contiguous blob,
subdivided by regions labeled in atlas.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>r = subdivide_by_atlas(r);
r(cat(1, r.numVox) &lt; 20) = []; % get rid of small regions
cluster_orthviews(r, &#39;unique&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;region.subdivide_by_local_max">
<code class="descclassname">&#64;region.</code><code class="descname">subdivide_by_local_max</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.subdivide_by_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide regions into sub-regions based on local peak Z-scores/maxima</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subregions</span> <span class="o">=</span> <span class="n">subdivide_by_local_max</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;mm_distance&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;noorthviews&#39;</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>mm_distance:</strong></dt>
<dd><p class="first last">Followed by mm distance minimum for dividing subclusters</p>
</dd>
<dt><strong>noorthviews:</strong></dt>
<dd><p class="first last">Suppress display of orthviews</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>subregions:</strong></dt>
<dd><p class="first last">subdivided region object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>region.subdivide_by_atlas, subclusters_from_local_max, cluster_local_maxima</p>
</dd></dl>

<dl class="function">
<dt id="&#64;region.surface">
<code class="descclassname">&#64;region.</code><code class="descname">surface</code><span class="sig-paren">(</span><em>r</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Surface method for region object - renders blobs on multiple types of 3-D surface</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[all_surf_handles, pcl, ncl] = surface(r, [&#39;cutaways&#39;, any optional inputs to surface_cutaway])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r:</strong></dt>
<dd><p class="first last">A region object</p>
</dd>
<dt><strong>cutaway:</strong></dt>
<dd><dl class="first last docutils">
<dt>String command for rendering cutaways instead of the default</dt>
<dd><ul class="first last simple">
<li>default is call to mediation_brain_surface_figs</li>
<li>cutaways calls surface_cutaway</li>
<li>all optional arguments are passed to surface_cutaway</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>rightsurface:</strong></dt>
<dd><dl class="first last docutils">
<dt>String command for rendering a right frontal cortical</dt>
<dd><p class="first last">view complementary to &#8216;cutaways&#8217;</p>
</dd>
</dl>
</dd>
<dt><strong>foursurfaces:</strong></dt>
<dd><p class="first last">Compact plots of four surfaces</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Other optional inputs to surface_cutaway
e.g., &#8216;pos_colormap&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>all_surf_handles:</strong></dt>
<dd><p class="first last">surface patch handles</p>
</dd>
<dt><strong>pcl:</strong></dt>
<dd><p class="first last">region object with positive-only clusters</p>
</dd>
<dt><strong>ncl:</strong></dt>
<dd><p class="first last">region object with negative-only clusters</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Use surface(r), with optional arguments taken by surface_cutaway:
poscm = colormap_tor([1 .3 0], [1 1 0]); % orange to yellow
[all_surf_handles, pcl, ncl] = surface(r, &#39;cutaway&#39;, &#39;ycut_mm&#39;, -30, &#39;pos_colormap&#39;, poscm, &#39;existingfig&#39;);
[all_surf_handles2, pcl, ncl] = surface(r, &#39;foursurfaces&#39;, &#39;pos_colormap&#39;, poscm, &#39;neg_colormap&#39;, negcm);
[all_surf_handles2, pcl, ncl] = surface(r, &#39;foursurfaces&#39;, &#39;existingfig&#39;, &#39;color_upperboundpercentile&#39;, 95, &#39;color_lowerboundpercentile&#39;, 5, &#39;neg_colormap&#39;, colormap_tor([0 0 1], [.4 0 .7]));

% use mediation_brain_surface_figs and re-make colors
all_surf_handles = mediation_brain_surface_figs([]);
surface(r, &#39;cutaway&#39;, &#39;surface_handles&#39;, all_surf_handles, &#39;color_upperboundpercentile&#39;, 95, &#39;color_lowerboundpercentile&#39;, 5, &#39;neg_colormap&#39;, colormap_tor([0 0 1], [.2 0 .5]));
</pre></div>
</div>
<p>:See also:*</p>
<p>surface_cutaway, cluster_surf, mediation_brain_surface_figs
..</p>
<blockquote>
<div>DEFAULTS AND INPUTS</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="&#64;region.table">
<code class="descclassname">&#64;region.</code><code class="descname">table</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@region.table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a table of all regions in a region object (cl)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[poscl, negcl] = table(cl, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Optional inputs:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>k:</strong></dt>
<dd><p class="first last">Print only regions with k or more contiguous voxels</p>
</dd>
<dt><strong>nosep:</strong></dt>
<dd><p class="first last">do not separate cl with pos and neg effects based on peak in .val</p>
</dd>
<dt><strong>names:</strong></dt>
<dd><p class="first last">name clusters before printing to table and output; saves in .shorttitle field</p>
</dd>
<dt><strong>forcenames:</strong></dt>
<dd><p class="first last">force naming of cl by removing existing names in .shorttitle field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first last">Returns region objects for cl with pos and neg effects, limited by size if entered
and named if entered as optional input</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-&#64;statistic_image">
<span id="statistic-image"></span><h1>statistic_image<a class="headerlink" href="#module-@statistic_image" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="&#64;statistic_image.conjunction">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">conjunction</code><span class="sig-paren">(</span><em>si1</em>, <em>si2</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.conjunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the conjunction of two statistic_images.  considers positive and
negative activations separately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body">Two thresholded statistic images.  Optional 3rd argument:  -1 to</td>
</tr>
</tbody>
</table>
<p>get only negative conjunction, or 1 to get only positive conjunction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Output:</th><td class="field-body">A statistic_image with all voxels suprathreshold (in the same direction) in both input</td>
</tr>
</tbody>
</table>
<p>images.  Voxel values are set to 1 and -1, to indicate direction.</p>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.convert2mask">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">convert2mask</code><span class="sig-paren">(</span><em>stats_image_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.convert2mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts each image in a statistic_image object into a mask object, based
on significant voxels in the .sig field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cl</span> <span class="o">=</span> <span class="n">region</span><span class="p">(</span><span class="n">convert2mask</span><span class="p">(</span><span class="n">timg</span><span class="p">),</span> <span class="n">group</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.multi_threshold">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">multi_threshold</code><span class="sig-paren">(</span><em>dat</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.multi_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiple threshold function for statistic_image object for visualization</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[o2, sig, pcl, ncl] = multi_threshold(dat, [optional inputs])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat:</strong></dt>
<dd><p class="first last">a statistic_image object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>poscolors:</strong></dt>
<dd><p class="first last">followed by cell array of colors for positive values, one per thresh</p>
</dd>
<dt><strong>negcolors:</strong></dt>
<dd><p class="first last">followed by cell array of colors for negative values, one per thresh</p>
</dd>
<dt><strong>thresh:</strong></dt>
<dd><p class="first last">followed vector of p-value thresholds, one per thresh</p>
</dd>
<dt><strong>sizethresh:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by vector of cluster sizes, one per thresh</dt>
<dd><ul class="first last simple">
<li>this &#8216;prunes&#8217; by default, so sizes after first can be 1
voxel</li>
<li>Default thresholds: thresh = [.001 .005 .05],
10 voxels at .001, &#8220;pruned&#8221;</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>nodisplay:</strong></dt>
<dd><p class="first last">suppress fmridisplay</p>
</dd>
<dt><strong>o2:</strong></dt>
<dd><dl class="first last docutils">
<dt>followed by an existing fmridisplay object</dt>
<dd><ul class="first last simple">
<li>will remove blobs and re-use montages</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>o2:</strong></dt>
<dd><p class="first last">handle to fmridisplay object created by default</p>
</dd>
<dt><strong>sig:</strong></dt>
<dd><dl class="first last docutils">
<dt>vector of significant voxels at each thresh, for each region</dt>
<dd><ul class="first simple">
<li>cell array of images in object with matrix of values</li>
</ul>
<p class="last">for each threshold</p>
</dd>
</dl>
</dd>
<dt><strong>pcl:</strong></dt>
<dd><dl class="first last docutils">
<dt>positive valued clusters cell, one cell per threshold</dt>
<dd><ul class="first last simple">
<li>FIRST image in object only</li>
<li>pass into mediation_brain_surface_figs.m</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>ncl:</strong></dt>
<dd><dl class="first last docutils">
<dt>positive valued clusters cell, one cell per threshold</dt>
<dd><ul class="first last simple">
<li>FIRST image in object only</li>
<li>pass into mediation_brain_surface_figs.m</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Examples:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[o2, sig, poscl, negcl] = multi_threshold(hr_intercept, &#39;nodisplay&#39;);
mediation_brain_surface_figs(poscl, negcl);

% Create empty montage set and (re)use it:
o2 = canlab_results_fmridisplay([], &#39;compact2&#39;, &#39;noverbose&#39;);
o2 = multi_threshold(out.t, &#39;o2&#39;, o2);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>mediation_brain_surface_figs, iimg_multi_threshold, mediation_brain_results</p>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.orthviews">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">orthviews</code><span class="sig-paren">(</span><em>image_obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.orthviews" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthviews display (SPM) for CANlab object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cl = orthviews(image_object)

% OR

cl = orthviews(image_object, handle_number of existing orthviews)
</pre></div>
</div>
<p>Output is clusters structure (see also region.m)</p>
<p>Pass in &#8216;largest_region&#8217; to center the orthviews on the largest region in the  image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% T-test, Construct a stats_image object, threshold and display:
statsimg = ttest(fmridat, .001, &#39;unc&#39;);

% Re-threshold and display:
statsimg = threshold(statsimg, .000001, &#39;unc&#39;);
orthviews(statsimg);

statsimg = threshold(statsimg, .01, &#39;fdr&#39;);
orthviews(statsimg);

% Create an orthviews and view at multiple thresholds in different panes:
overlay = which(&#39;SPM8_colin27T1_seg.img&#39;);
spm_check_registration(repmat(overlay, n, 1));
statsimg = ttest(fmridat);
statsimg = threshold(statsimg, .001, &#39;unc&#39;);
orthviews(statsimg, &#39;handle&#39;, 1);

statsimg = threshold(statsimg, .000001, &#39;unc&#39;);
orthviews(statsimg, &#39;handle&#39;, 2);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">statistic_image.multi_threshold</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.reparse_contiguous">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">reparse_contiguous</code><span class="sig-paren">(</span><em>obj</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.reparse_contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-construct list of contiguous voxels in an image based on in-image
voxel coordinates.  Coordinates are taken from obj.volInfo.xyzlist.
Results are saved in obj.volInfo.cluster.
xyzlist can be generated from iimg_read_img, and is done automatically by
object-oriented fMRI image classes (fmri_image, image_vector,
statistic_image)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span> <span class="o">=</span> <span class="n">reparse_contiguous</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;nonempty&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>If &#8216;nonempty&#8217; is entered as an optional argument, will use only voxels
that are non-zero, non-nan in the first column of obj.dat.</p>
<p>The statistic_image object version of reparse_contiguous uses 
the significance of the first image in the object (obj.sig(:, 1)) as a
filter as well, so clustering will be based on the latest threshold applied.
it is not usually necessary to enter &#8216;nonempty&#8217;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Given timg, a statistic_image object:
test = reparse_contiguous(timg, &#39;nonempty&#39;);
cl = region(test, &#39;contiguous_regions&#39;);
cluster_orthviews(cl, &#39;unique&#39;)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.select_one_image">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">select_one_image</code><span class="sig-paren">(</span><em>obj</em>, <em>wh</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.select_one_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="&#64;statistic_image.threshold">
<code class="descclassname">&#64;statistic_image.</code><code class="descname">threshold</code><span class="sig-paren">(</span><em>stats_image_obj</em>, <em>input_threshold</em>, <em>thresh_type</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#@statistic_image.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Threshold statistic_image object based on statistical threshold values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>stats_image_obj = threshold(stats_image_obj, pvalthreshold or other thresh, thresh_type, [&#39;k&#39;, extent_thresh])
</pre></div>
</div>
<p>This is a method for an statistic_image object.
Thresholding is reversible.</p>
<dl class="docutils">
<dt>For objects: Type methods(object_name) for a list of special commands</dt>
<dd>Type help object_name.method_name for help on specific
methods.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>stats_image_obj:</strong></dt>
<dd><p class="first last">statistic_image object</p>
</dd>
<dt><strong>input_threshold:</strong></dt>
<dd><p class="first last">[pvalthreshold or other thresh]
A numeric value corresponding to the threshold desired.
Either a p-value or a range of raw values, depending on the threshold
type.</p>
</dd>
<dt><strong>thresh_type:</strong></dt>
<dd><dl class="first last docutils">
<dt>Threshold type which can be one of:</dt>
<dd><ul class="first last simple">
<li>&#8216;fdr&#8217; : FDR-correct based on p-values already stored in image .p field</li>
<li>&#8216;fwe&#8217; : FWE-correct; not implemented</li>
<li>&#8216;bfr&#8217; : Bonferroni correction (FWE).</li>
<li>&#8216;unc&#8217; : Uncorrected p-value threshold: p-value, e.g., .05 or .001</li>
<li>&#8216;raw-between&#8217; : threshold raw image values; save those &gt; input_threshold(1) and &lt; input_threshold(2)</li>
<li>&#8216;raw-outside&#8217; : threshold raw image values; save those &lt; input_threshold(1) or &gt; input_threshold(2)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>k:</strong></dt>
<dd><p class="first last">Followed by cluster extent in voxels: extent-based thresholding of any of the above</p>
</dd>
<dt><strong>noverbose:</strong></dt>
<dd><p class="first last">Suppress verbose output</p>
</dd>
<dt><strong>mask:</strong></dt>
<dd><dl class="first last docutils">
<dt>Followed by name of mask or fmri_mask_image object</dt>
<dd><ul class="first last simple">
<li>this will affect corrected significance levels</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>stats_image_obj:</strong></dt>
<dd><p class="first last">thresholded statistic_image object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Retain sig pos or neg results at p &lt; .001 uncorrected, cluster extent &gt;= 100 voxels
obj = threshold(obj, .001, &#39;unc&#39;, &#39;k&#39;, 100)

% Retain sig pos or neg results at q &lt; .05 FDR, cluster extent &gt;= 10 voxels
obj = threshold(obj, .05, &#39;fdr&#39;, &#39;k&#39;, 10)

% Retain voxels with absolute statistic/data value &gt; 3
obj = threshold(obj, [-3 3], &#39;raw-outside&#39;)

dat = threshold(dat, 0.001, &#39;unc&#39;, &#39;k&#39;, 35, &#39;mask&#39;, which(&#39;scalped_avg152T1_graymatter_smoothed.img&#39;));
dat = threshold(dat, 0.001, &#39;unc&#39;, &#39;k&#39;, 35, &#39;mask&#39;, maskobj);
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>image_vector.threshold, statistic_image.multi_threshold</p>
</dd></dl>

</div>
<div class="section" id="cluster-contig-region-tools">
<h1>Cluster_contig_region_tools<a class="headerlink" href="#cluster-contig-region-tools" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-Cluster_contig_region_tools"></span><dl class="function">
<dt id="Cluster_contig_region_tools.anat_subclusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">anat_subclusters</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.anat_subclusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters voxels within &#8216;clusters&#8217; structure based on anatomical locations
in space.  Outputs subgroups of smaller clusters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>clout = anat_subclusters(cl,[resume at],[output cl to resume])
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster2region">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster2region</code><span class="sig-paren">(</span><em>cl</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster2region" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a CANlab/SCANlab &#8220;clusters&#8221; structure into a region object, the
standard in 2011 toolbox functions and beyond.</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster2subclusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster2subclusters</code><span class="sig-paren">(</span><em>cl_in</em>, <em>class</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster2subclusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a single cluster cl_in and separate into subclusters based on
vector of integers class</p>
<p>Class must code unique subclusters subcluster order is only preserved
if class contains all integers from 1 to nclasses:</p>
<p>i.e., class 3 will only be in subcluster 3 if there are no missing class
numbers in class</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_close_enough">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_close_enough</code><span class="sig-paren">(</span><em>cl_match_to</em>, <em>cl_match</em>, <em>mind</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_close_enough" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds whether each cluster center in cl_match is within mind mm of a cluster
center in cl_match_to.</p>
<p>Useful for selecting a list of clusters that are not close to another
list to, e.g., make a table of.  or this could be used to find clusters
in a set of correlated clusters that are close to centers in activated
clsuters.</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_export_pngs">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_export_pngs</code><span class="sig-paren">(</span><em>cl</em>, <em>useexisting</em>, <em>overlay</em>, <em>xhairson</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_export_pngs" title="Permalink to this definition">¶</a></dt>
<dd><p>Save png images of SPM orthviews windows for each cluster in a set (cl
structure)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cl</span> <span class="o">=</span> <span class="n">cluster_export_pngs</span><span class="p">(</span><span class="n">cl</span><span class="p">,[</span><span class="n">useexisting</span><span class="p">],[</span><span class="n">overlayimagename</span><span class="p">],[</span><span class="n">xhairson</span><span class="p">])</span>
</pre></div>
</div>
<p>names from cl(x).shorttitle are used
useexisting is optional: 1 uses existing orthviews display (default), 0 creates a
new one with the clusters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% use existing
cluster_export_pngs(cl, 1, EXPT.overlay);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_find_index">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_find_index</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_find_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Ever see an interesting blob when visualizing a clusters structure, but
don&#8217;t know which index number in the clusters structure vector it
corresponds to?</p>
<p>With this function, find the index number of the closest cluster to one you specify
graphically by clicking on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function [wh_cluster, min_distance] = cluster_find_index(cl, [keep display flag, 1/0])
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_interp">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_interp</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_interp" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Interpolates voxels and mm in a clusters structure (cl) to match the</dt>
<dd><p class="first">image dimensions and voxel sizes of a target mask image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function cl = cluster_interp(cl,maskimg,[keep sep clusters flag])
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="last highlight-python"><div class="highlight"><pre>cl = cluster_interp(cl,maskimg,1);

%default mask 2 x 2 x 2, SPM2 default:
cl = cluster_interp(cl,[],1);
</pre></div>
</div>
</dd>
</dl>
<p>maskimg = which(&#8216;scalped_avg152T1_graymatter_smoothed.img&#8217;);</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_intersection">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_intersection</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intersection of the clusters passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>intersect_cl = cluster_intersection(cl1, cl2, cl3, ...)

% simple intersection
cl = cluster_intersection(robust0001_poscl(2), robust0002_poscl(4), robust0003_poscl(17));

% intersection between sets of clusters
% alternatively, see cluster_set_intersection.m
cl = cluster_intersection(clusters2CLU(robust0001_poscl), clusters2CLU(robust0002_poscl));
</pre></div>
</div>
<dl class="docutils">
<dt>Note:</dt>
<dd>Only works with single clusters. To compute the intersection between sets of clusters,
use cluster_set_intersection()</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_local_maxima">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_local_maxima</code><span class="sig-paren">(</span><em>cl</em>, <em>dthresh</em>, <em>verbose</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Clusters are chosen so that they must be at least dthresh mm apart
default is 10 mm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[xyz, XYZmm, Z, class] = cluster_local_maxima(cl, [dthresh], [verbose])
</pre></div>
</div>
<p>verbose output: 1/0, default is 0</p>
<p>additional optional outputs (slower):</p>
<p>class: vector of integers for which subcluster this cluster belongs to</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_set_intersection">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_set_intersection</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_set_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intersection of the sets of clusters passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">intersect_cl</span> <span class="o">=</span> <span class="n">cluster_set_intersection</span><span class="p">(</span><span class="n">cls1</span><span class="p">,</span> <span class="n">cls2</span><span class="p">,</span> <span class="n">cls3</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">cl</span> <span class="o">=</span> <span class="n">cluster_intersection</span><span class="p">(</span><span class="n">robust0001_poscls</span><span class="p">,</span> <span class="n">robust0002_poscls</span><span class="p">,</span> <span class="n">robust0003_poscls</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Note:</dt>
<dd>Designed for sets of clusters. To compute the intersection between individual clusters,
use cluster_intersection(). cluster_set_intersection will work, but is not needed.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_table">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_table</code><span class="sig-paren">(</span><em>clusters</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print output of clusters in table</p>
<p>Option to print text labels from Carmack atlas.</p>
<p>Database loading is done from talairach_info.mat which should be in the 
path.</p>
<p>To speed up performance, load talairach_info.mat in the base workspace or
calling function and include xyz, L3 and L5 as inputs to cluster_table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% create subclusters on the fly, prompt for labels
cluster_table(cl);

% no subclusters, no labels
cluster_table(cl, 0, 0);

% do subclusters, no labels
cluster_table(cl, 1, 0);

create subclusters on the fly, do labels
cluster_table(cl, 1, 1);

% 3 input variables following &#39;tal_info&#39; are interpreted as xyz, L3,
% and L5 from talairach_info.mat.
cluster_table(..., &#39;tal_info&#39;, xyz, L3, L5);

% loads labels from taldata.mat (Talairach database) instead of
% talairach_info.mat. Note that you should use the &#39;tal_info&#39; call
% above if xyz, L3, and L5 have already been loaded to theworkspace
% from taldata.mat. Also, if the talairach database is being used,
% your cl.XYZmm values MUST correspond to the TALAIRACH, NOT MNI,
% database, or the labels will be innaccurate.
cluster_table(..., &#39;talairach&#39;);

% print table to ASCII file, &#39;filename&#39;, instead of to the matlab
% command window.
cluster_table(..., &#39;writefile&#39;,&#39;filename&#39;);

% any set of inputs from above, also print clusters.myfield in output
cluster_table(..., &#39;myfield&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.cluster_table_successive_threshold">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">cluster_table_successive_threshold</code><span class="sig-paren">(</span><em>cl</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.cluster_table_successive_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster table of a cell array of clusters cl{1} cl{2} etc.
Prints table of cl{1} and then any additional regions in cl{2:n} that are
not within 10 mm of a previously printed cluster</p>
<p>Also: merges clusters in set within 10 mm</p>
<p>Table titles are hard-coded to be consistent with meta-analysis toolbox right now</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cl</span> <span class="o">=</span> <span class="n">cluster_table_successive_threshold</span><span class="p">(</span><span class="n">cl</span><span class="p">,[</span><span class="n">sizethr</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Print a series of tables with custom fields:
cl = cluster_table_successive_threshold(cl,5,&#39;myfield1&#39;,&#39;myfield2&#39;)
</pre></div>
</div>
<p>Use <em>merge_nearby_clusters</em> and <em>subclusters_from_local_max</em>
or some other way to get clusters appropriately separated and distanced
before running.
see Meta_cluster_tools for code to run this for meta-analysis.</p>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.clusters2CLU">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">clusters2CLU</code><span class="sig-paren">(</span><em>clusters</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.clusters2CLU" title="Permalink to this definition">¶</a></dt>
<dd><p>Inputting an M matrix will transform the coordinates
by that M, to convert between voxel sizes, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function CLU = clusters2CLU(clusters,[opt] M)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.clusters2mask">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">clusters2mask</code><span class="sig-paren">(</span><em>cl</em>, <em>V</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.clusters2mask" title="Permalink to this definition">¶</a></dt>
<dd><p>This function has 2 modes!  If V is a structure:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[m,V,cl] = clusters2mask(cl,V,[opt: write Z-scores])
</pre></div>
</div>
<p>Converts clusters structure to a mask image, given V structure with V.mat
field.  V.mat is an SPM mat file. V.dim is dims of image uses cl.XYZmm
m is mask img data, V is mask vol info.</p>
<p>Also replaces cl.XYZ (voxels)</p>
<p>If V is a vector of mask dimensions:
converts clusters to mask image using existing XYZ and dims of mask</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">voxels2mask, for a faster function that uses XYZ voxel coords</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% Save an image file with just one cluster from a set (#7 in this ex.)
cl = mask2clusters(&#39;roi_group1.img&#39;);
V = spm_vol(&#39;roi_group1.img&#39;);  % we need .mat and .dim from this, or

% just dim
[m,V,cl] = clusters2mask(cl(7),struct(&#39;mat&#39;,cl(1).M,&#39;dim&#39;,V.dim));
%or
[m,V,cl] = clusters2mask(cl(7),V);

clusters2mask(cl,struct(&#39;mat&#39;,V.mat,&#39;dim&#39;,V.dim),0,&#39;spm2_hy.img&#39;);

%for SPM5:
clusters2mask(cl,struct(&#39;mat&#39;,V.mat,&#39;dim&#39;,V.dim, &#39;dt&#39;, V.dt),0,&#39;spm2_hy.img&#39;);
clusters2mask(cl,
struct(&#39;mat&#39;,MC_Setup.volInfo.mat,&#39;dim&#39;,MC_Setup.volInfo.dim, &#39;dt&#39;, MC_Setup.volInfo.dt),0,&#39;acc_roi_mask.img&#39;);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.image2clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">image2clusters</code><span class="sig-paren">(</span><em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.image2clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Menu-driven function for getting clusters from an image file (e.g., a
t-image)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cl = image2clusters([overlay image name])
</pre></div>
</div>
<p>Can also return clusters active in two contrasts, sorted by increases in
both, decreases in both, inc in first, dec in first
useful for testing whether something is both activated and correlated!
e.g., see active_plus_corr_scatterplot_plugin</p>
<p>% :Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">pospos</span><span class="p">,</span><span class="n">negneg</span><span class="p">,</span><span class="n">posneg</span><span class="p">,</span><span class="n">negpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">image2clusters</span><span class="p">(</span><span class="n">overlay</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.mask2clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">mask2clusters</code><span class="sig-paren">(</span><em>P</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.mask2clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts clusters and con img data from mask</p>
<p>Use with <em>mask_intersection.m</em></p>
<p>To get clusters but not extract data, enter only one argument.</p>
<p>To get clusters and choose extraction imgs with the GUI, enter an empty [] 2nd argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>[clusters,CLU,subclusters] = mask2clusters(img mask file with voxels,[imgs to extract data from],[df])
</pre></div>
</div>
<p>DOES <em>NOT</em> CONVERT BETWEEN DIFFERENT VOXEL SIZES AND POSITIONS BETWEEN IMNAMES AND SPM/VOL STRUCTS</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body">roi_probe</td>
</tr>
</tbody>
</table>
<p>If no imgs are entered, Z-scores are values from mask</p>
<p>If df is entered, values in mask img are converted to Z-scores with spm_t2z.m</p>
<p>If extract img names are empty and df is entered, assume we&#8217;re using
values from mask as t-values and convert to Z-scores</p>
<p>WARNING: for spm2 compatibility, ABSOLUTE VALUES of voxel sizes are
returned; e.g., ignores analyze flipping in SPM2.</p>
<p>% Matlab 6.5/OSX bug gives seg fault or something if mask is too big.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>cl = mask2clusters(&#39;myimage.img&#39;,[img string mtx],[]); % no z-score
conversion, extracts data from [img string mtx]

cl = mask2clusters(&#39;rob_tmap_0002_filt_t_3-05_k10_neg.img&#39;)

% This one works with already-loaded image data and a mat matrix:
V = spm_vol(&#39;rob_tmap_0002_filt_t_3-05_k10_neg.img&#39;); dat = spm_read_vols(V);
cl = mask2clusters(dat,V.mat);
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.mask2struct">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">mask2struct</code><span class="sig-paren">(</span><em>maskname</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.mask2struct" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function V = mask2struct(maskname,crit_t,cl_size)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><dl class="first docutils">
<dt><strong>maskname:</strong></dt>
<dd><p class="first last">name of spmT, con, or filtered image without .img extension,
in single quotes</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional Inputs:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><strong>crit_t, cl_size::</strong></dt>
<dd><p class="first last">critical t and cluster size at which to mask</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Outputs:</th><td class="field-body"><p class="first">structure compatible with SPM viewing and with cluster definition
algorithm tor_extract_rois</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% to extract clusters:
[clusters] = tor_extract_rois(maskname,V,V);

% to display:
spm_image   (and choose anatomical)
spm_orthviews(&#39;AddBlobs&#39;,1,V.XYZ,V.Z,V.mat)
spm_orthviews(&#39;AddColouredBlobs&#39;,1,V.XYZ,V.Z,V.mat,[0 0 1])

% to overlay on Talairach atlas
fixed_TSU(clusters)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.merge_clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">merge_clusters</code><span class="sig-paren">(</span><em>c2m</em>, <em>subcl</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.merge_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for synchronizing the field list of cluster structures
and merging them</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subclusters</span> <span class="o">=</span> <span class="n">merge_clusters</span><span class="p">(</span><span class="n">clusters_to_match</span><span class="p">,</span> <span class="n">subclusters_to_change</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.merge_nearby_clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">merge_nearby_clusters</code><span class="sig-paren">(</span><em>cl</em>, <em>thr</em>, <em>varargin</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.merge_nearby_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge sets of clusters whose centers are all within thr mm of each other
uses parcel_complete_sets.m</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">newcl</span> <span class="o">=</span> <span class="n">merge_nearby_clusters</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">thr</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>% The command below runs the function recursively until all clusters are
% greater than thr mm apart
newcl = merge_nearby_clusters(cl, thr, &#39;recursive&#39;)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.subclusters_from_local_max">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">subclusters_from_local_max</code><span class="sig-paren">(</span><em>cl</em>, <em>dist_thresh</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.subclusters_from_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Breaks apart a cluster into smaller clusters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subcl</span> <span class="o">=</span> <span class="n">subclusters_from_local_max</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="Cluster_contig_region_tools.xyz2clusters">
<code class="descclassname">Cluster_contig_region_tools.</code><code class="descname">xyz2clusters</code><span class="sig-paren">(</span><em>xyz</em>, <em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#Cluster_contig_region_tools.xyz2clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a 3-column x, y, z list of mm coordinates to a clusters
structure given P, the filename of an analyze .img file to provide
dimensions and voxel sizes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre>function cl = xyz2clusters(xyz,P)
</pre></div>
</div>
<dl class="docutils">
<dt>Uses this info from the image:</dt>
<dd><ul class="first last simple">
<li>VOL.M     - spm-style mat matrix</li>
<li>VOL.VOX   - voxel sizes</li>
<li>SPM.Z     - now 1s; could stores values in the original image in clusters.Z</li>
</ul>
</dd>
<dt>The following is created internally:</dt>
<dd><ul class="first last simple">
<li>SPM.XYZmm - mm coords, you input these</li>
<li>SPM.XYZ   - voxel coords</li>
</ul>
</dd>
</dl>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Object Oriented Tools</a></li>
<li><a class="reference internal" href="#module-&#64;canlab_dataset">canlab_dataset</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_data">fmri_data</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_mask_image">fmri_mask_image</a></li>
<li><a class="reference internal" href="#module-&#64;fmri_model">fmri_model</a></li>
<li><a class="reference internal" href="#fmridisplay">fmridisplay</a></li>
<li><a class="reference internal" href="#module-&#64;image_vector">image_vector</a></li>
<li><a class="reference internal" href="#module-&#64;region">region</a></li>
<li><a class="reference internal" href="#module-&#64;statistic_image">statistic_image</a></li>
<li><a class="reference internal" href="#cluster-contig-region-tools">Cluster_contig_region_tools</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/oo_tools.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="mat-modindex.html" title="MATLAB Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CanlabCore 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Tor Wager.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>